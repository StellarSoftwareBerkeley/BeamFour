package com.stellarsoftware.beam;

import java.text.DecimalFormat; // for debugging only

/** This file contains public class RT13 and private class MinFit
  *
  *
  *  A188, 189: adopted class Triple for refraction, diffraction
  *  A186 Sep 2015: eliminated final refraction into vacuum in getRefraction()
  *  A169 March 2015: Added RTANGLE each intercept ray dot normal, in iRedirect.
  *
  * Schematic ray loop, without bailouts:
  *
  *    for (j=1; j<=nsurfs; j++)
  *    {
  *        labtovx(ray[j-1], ray[j], surf[j]); // translate then rotate to localframe
  *        d = dIntercept(ray[j], surf[j]);    // evaluate distance to intercept
  *        vPropagate(ray[j], d, surf[j]);     // advance ray to surface
  *        iRedirect(ray[j], surf[j]);         // redirect ray in local frame
  *        vxtolab(ray[j], surf[j]);           // rotate then translate to labframe
  *    }
  *
  *
  *    PHANTOM HYPERBOLOIDS DO NOT EXIST  "mis"
  *    FARSIDE ELLIPSOIDS DO NOT EXIST    "mis"
  *
  * A166 Jan 2015: reworked redirectors CBin, CBout: now copies local to local.
  * A154: installed Bimodal lens, new logic; TIR failures...
  * A148: removed Bimodal lenses.
  * A147: installing Bimodal lens that can bypass a Dia or dia fault.
  *  new optics surface types: OTBLFRONT, OTBLBACK;
  *  new ray failure codes:  RRBII, RRBIO
  *  Diams decision is moved into iRedirect to handle these situations. 
  *  iIntercept(): line 982;  iDiams(): line 915; iRedirect(): line 1555.
  *  
  * A143: Reinstalling groups. Issues:
  *  LayoutPanel and MapPanel both call dGetSurf(): illegal with groups.
  *
  * A139: Eulers now correspond to the Users Guide: convert from local to lab.
  *   Impact: RT13 labtovx(), vxtolab(), setEulers(), LayoutPanel.
  *
  * To run the rays, call public method iBuildRays(bAll, nrays, nsurfs).
  *   Here, use nsurfs, not ngroups.  Collapsing to groups happens later. 
  *   Runs all table rays,
  *   Makes output available as dRays[][][].
  *   Computes all ganged goals
  *   Computes WFE, using MinFit for pupil piston & slopes
  *
  * rev 137, simplified, with NO GROUPS; see bRunOneRay(), line 288
  *
  * rev 134, Feb 2012: installed iGetPosRoots() to simplify dQuadsolve(). 
  *   this new routine means that BAK roots can be promptly dismissed
  *   thereby simplifying the gnarly root selection logic: hyperboloid sheet,
  *   oblate & prolate cases are sweetly distinguished; parabolas always OK.
  *   Two good roots: dQuadSolve() now calls new testDiameter().
  *   New default for two good roots: return shorter path i.e. "first" intercept.
  *   The "<" type tag is redefined as root closer to the vertex.
  *   The ">" type tag continues to serve longer ray path intercept. 
  * 
  *   A complete ellipsoid can be made by grouping two hemiellipsoids;
  *   see new example 9-17 p.53 Ellipsoid.OPT and Ellipsoid.RAY.
  *
  * rev 133: Feb 2012: dQuadSolve was permitting farside intercepts.
  *   Yikes. Bizarre layouts!  Steve Tulk's questions about this. 
  *   See line 1085 and the booleans OK0 and OK1.
  *
  * rev 128: added iScatter(), a Gaussian forward scatter surface. 
  *   but no iBragg() since 2d.sin(theta)/Lam is never an integer.
  *
  * rev 123: dQuadSolve has 16 state decision tree. 
  *
  * Default quadratic intercept is posroot nearer vertex.
  * Policy override "<" (shorter) and ">" (longer) is in dQuadSolve(). 
  *
  * Random rays (k==0) are generated by iInitRaySeq(), line 700 below.
  *
  * To enforce use of iBuildRays() and reject client loops through bRunray(),
  * bRunray(kray) is now private.  But to allow its use for individual
  * random rays, a new public method bRunRandomRay() handles WFE and
  * calls private bRunray(0)
  *
  * rev 112: Groups are introduced.  Public arrays are set by OEJIF:
  *    RT13.jstart[g]
  *    RT13.jstop[g]
  *    RT13.group[j]
  * but beware j[group] is not stored, it is ray dependent.
  *
  * rev 104: Reworking the near/far intercept permissions for conics.
  *  Problem has been farside intercepts = valid when ought to fail. 
  *  Failure code "bak" seems to be unavailable, but is needed in this case.
  *
  * rev 118: includes biconic surface profile.  See Z.java
  *
  * rev A62: WFE correction method (line 377) is available to all rays.
  *
  * rev A34: nstalled analytic differentiator for all surfaces;
  * this will need exhaustive testing, including "farside" intercepts. 
  *
  * Relies upon Z.vGetZsurf() for the surface model beyond conics & cylinders.
  * Relies upon Z.vGetPerp() for all gradients. 
  *
  * Parameter "howfar" is how far the loop went, ray=OK or not.
  * HowFarGood = RROK ? howfar : howfar-1.
  * Reason:  In "Message NN" the NN = howfar, and message is OK or fail.
  * 
  * 
  * Method initRaySeq() is private, no client interfaces;
  * Calling initRaySeq() within bRunray() case (krand==1) setup. 
  *
  * public output methods: getStatus(), getHowfar(), getExtend().
  *
  *
  * setTableDirection()    handles RayTable & DefaultRay choices
  * setRandomDirection()   called here in bRunray(): uses smins, spans
  *
  *-------------------Dramatis Personae of runray()----------------------
  *    iIntercept() uses analytic or Brent  << does not modify ray[].
  *    vPropagate() is self sufficient      << modifies xyz of ray[].
  *    iDiams() is self sufficient          << does not modify ray[].
  *    iRedirect() calls vGetPerp()         << modifies uvw of ray[]. 
  *    Note: vGetPerp() converts to 3-dim, calls Z.vGetPerp()
  *          and then converts 3-dim back to 13-dimensions. 
  *
  * Solvers provide recommended ray distances "d" but do not propagate.
  * Reason: there is sanity testing for each recommended solution. 
  * Especially so with Groups!
  *
  * Main loop bRunray() must explicitly propagate, then call iDiams() for logic.
  * 
  *
  *----public input arrays----------- 
  *      surfs[][]          << filled by OEJIF; modified by Map,MPlot..
  *      raystarts[][]      << filled by REJIF; modified by AutoRay
  *      iWFEgroup[]        << filled by REJIF
  *      spans[]            << filled by REJIF after WFEgroup
  *      smins[]            << filled by REJIF after WFEgroup
  *      media[][]          << filled by MEJIF
  *
  *----output array-------------- 
  *      dRays[][][]        << now private! replaced by a public accessor.
  *      dGetRay(kray, jsurf, iattrib) to include WFE, whose internal 
  *      organization is very different from dRays[].
  *
  * Uses no classes other than Consts; LUTs are based *here*. 
  * Based on 13-element rays: lab6 + local6 + path. 
  *
  *
  *   Client REJIF must set up raystarts[][], smins[], spans[];
  *      --raystarts[] should NOT include defaults, nor fixups.
  *      --all missing data flagged by REJIF as -0.0
  *   Client then must run iBuildRays()
  *
  *   Client can ask for any resulting datum for any ray:
  *       int getHowfar(), int getStatus(), double dGetRay(k, g, attrib).
  *   runseq[][] is dwells within this class.
  *
  * Internally, VxtoLab etc all act on a 13-element ray not 6-element ray.
  *
  *
  *
  *
  * @author M.Lampton (c) STELLAR SOFTWARE 2004 all rights reserved.
  */
class RT13 implements B4constants
{
    /*--------public input working arrays for OEJIF and REJIF------*/

    public static double  surfs[][]      = new double[MAXSURFS+1][ONPARMS]; 
    public static double  raystarts[][]  = new double[MAXRAYS+1][RNSTARTS]; 
    public static double  spans[][]      = new double[MAXWFEGROUPS][RNSTARTS];
    public static double  smins[][]      = new double[MAXWFEGROUPS][RNSTARTS];
    public static double  media[][]      = new double[MAXMEDIA+1][MAXFIELDS]; 

    public static int     gO2M[] = new int[MAXSURFS+1]; // from DMF
    public static int     gR2M[] = new int[MAXRAYS+1];  // from DMF

    //----gwave allows MPlotPanel to commandeer wavelengths; see getRefraction()---
    //------for all other purposes keep gwave=0 so rays control wavelengths--------

    public static int     gwave = 0;   
 
    /*----------Groups of surfaces, all filled in by OEJIF-------*/
    /*----- but of course j[g] is ray dependent.-----------------*/

    public static int jstart[] = new int[MAXGROUPS+1];  // group to surface
    public static int jstop[]  = new int[MAXGROUPS+1];  // group to surface
    public static int group[]  = new int[MAXSURFS+1];   // surface to group

    /*----------------public output arrays-------------------*/


    public static double  refractLayoutShading[] = new double[MAXSURFS+1]; 
    public static boolean bGoodRay[] = new boolean[MAXRAYS+1]; 
    public static int     iWFEgroup[] = new int[MAXRAYS+1];    // input from REJIF
    // public static double     dot[] = new double[MAXRAYS+1];  // moved into attribs
    

    /*------------------------------------------------------*/
    /*-------------------- public methods-------------------*/
    /*------------------------------------------------------*/

    static public double dGetRay(int kray, int g, int iattrib)
    // Accesses any one ray trace result, after iBuildRays() has been run.
    // "g" is the desired group number.
    {
        if ((iattrib >= RX) && (iattrib < RTWFE))  // now includes RTDOT
        {
            double x = dRays[kray][g][iattrib];
            return x; 
        }
        if (iattrib == RTWFE)
          return dWFE[kray]; //--why use a special array for WFE?
        return -0.0; 
    }


    static public double dGetSurf(int iatt, int jsurf)
    // Returns one of the many surface parameters & attributes. 
    // DO NOT USE THIS WITH GROUPS -- defined results only when ungrouped.
    // Needed for Map function when surface is to be deviated for mapping.
    // Called by MapPanel and LayoutPanel. 
    {
         if ((iatt < 0) || (iatt > ONPARMS))  // allows OTYPE etc
           return -0.0; 
         if ((jsurf < 1) || (jsurf > MAXSURFS))
           return -0.0; 
         return surfs[jsurf][iatt]; 
    }



    static public double dGetRayFinal(int kray, int iatt)
    // called by MapPanel after iBuildRays() has been run.
    // Averages over all groups. 
    {
        int jsurf = DMF.giFlags[ONSURFS]; 
        return dRays[kray][jsurf][iatt]; 
    }
    

    
    static public int iBuildRays(boolean bAll)
    // This runs all (or nearly all) table rays. 
    // NOTA BENE this is nsurfs not ngroups!  Because it uses bRunOneRay.
    // Builds dRays[] by calling bRunray() for each ray start.
    //  (bRunray() uses iInitRaySeq() to set up each ray, even random rays.)
    // Builds dWFE[] from aggregate dRays[].
    // If bAll=true, it tries all rays and writes bGoodRay[].
    // If bAll=false, it assumes bGoodRay[] is correct and runs only known good rays.
    // This is a laborsaver, used in Auto.  Check for freshly failed rays!
    // In either case it returns the number of good rays. 
    //
    // Be sure RT13.gwave=0 except for MPlotPanel external wavelength command. 
    // RT13.gwave is a key control parm for RT13.getRafraction(). 
    //
    // M.Lampton STELLAR SOFTWARE (C) 2007
    {
        int gnrays = DMF.giFlags[RNRAYS]; 
        int gnsurfs = DMF.giFlags[ONSURFS]; 
        int gngroups = DMF.giFlags[ONGROUPS]; 

        if ((gnrays < 1) || (gnrays > MAXRAYS))
          return 0; // SNH thanks to graying.
        if ((gnsurfs < 1) || (gnsurfs > MAXSURFS))
          return 0; // SNH thanks to graying.

        for (int k=0; k<=gnrays; k++)
          for (int grp=0; grp<=gngroups; grp++)
            for (int iatt=0; iatt<RNATTRIBS; iatt++)
              dRays[k][grp][iatt] = -0.0; 

        ngood = 0; 

        for (int k=1; k<=gnrays; k++)
          if (bAll || bGoodRay[k])
          {
              boolean bOK = bRunOneRay(k);  // copy to dRays[][][] from each rayseq[][].
              if (bOK)
                ngood++; 
              if (bAll)
                bGoodRay[k] = bOK;
              for (int grp=0; grp<=howfar[k]; grp++)
                for (int iatt=0; iatt<RNATTRIBS; iatt++)
                  dRays[k][grp][iatt] = rayseq[grp][iatt];  // also in bRunOneRay() ???
          }

        doWFEtask(ngood, gnrays, gngroups); 
        return ngood; 
    } //---end of iBuildRays()------



    static public boolean bRunOneRay(int kray) 
    // Runs a single ray. If kray==0, random ray; else table ray.
    // Outputs to runray[g][attrib] and   jfound[kray][group].
    // Returns TRUE if raystatus == RROK, else FALSE.
    // M.Lampton STELLAR SOFTWARE (c) 2012. 
    {
        int nsurfs = DMF.giFlags[ONSURFS]; 
        int ngroups = DMF.giFlags[ONGROUPS]; 
        int prevstatus = RROK; 
        boolean propagated = false; 

        stat[kray] = RROK;       // positive index to ray failure message
        int prev = RROK;         // shorthand raystatus for previous surface
        howfar[kray] = 0;        // progress indicator
        bExtend[kray] = false;
        kGuideRay = iInitRaySeq(kray, nsurfs);           // SETUP group zero ????
        jfound[kray][0] = 0; 
        
        for (int g=1; g<=ngroups; g++)                   // group loop
        {
            propagated = false;                          // no propagation yet
            howfar[kray] = g;                            // trying group "g"
            int j = getBestSurf(g);                      // finds first surface within g
            if ((j<g) || (j>nsurfs))                     // group failure (singles are OK here)
            {  
                stat[kray] = RRGRP;  
                break; 
            }

            jfound[kray][g] = j; 
            labtovx(rayseq[g-1], rayseq[g], surfs[j]);

            boolean bFront   = (OTBLFRONT==surfs[j][OTYPE]) && (OTBLBACK==surfs[j+1][OTYPE]);
            boolean bBack    = (OTBLFRONT==surfs[j-1][OTYPE]) && (OTBLBACK==surfs[j][OTYPE]);
            boolean bBimodal = bFront || bBack; 

            double d = dIntercept(rayseq[g], surfs[j]);
            if (d<0.0)                                   // intercept failure: bak, mis, Dia, ...
            {
                stat[kray] = (int) (-d);                 // miss or backward
                d = 0.0; 
                if (!bBimodal)
                {
                    vExtend(rayseq[g]);                  // short dotted extension
                    bExtend[kray] = true; 
                }
                else  // bimodal situation: relabel, no reversing needed
                {
                    if (stat[kray]==RRDIA)
                      stat[kray] = RRBO;
                    if (stat[kray]==RRdia)
                      stat[kray] = RRBI;
                    propagated = false;   // these did not use propagation
                }
            }

            if ((stat[kray]==RROK) || (bBack && bFrontOK(prev)))
            {
                double dIndex = getRefraction(g, kray); 
                vPropagate(rayseq[g], d, dIndex, surfs[j]);
                propagated = true; 
                stat[kray] = iDiams(rayseq[g], surfs[j]);  
                if (bBimodal && (stat[kray]==RRdia))
                  stat[kray] = RRBI; 
                if (bBimodal && (stat[kray]==RRDIA))
                  stat[kray] = RRBO;
            }

            if (propagated && ((stat[kray]==RRBI) || (stat[kray]==RRBO)))  // reverse
            {
                double dIndex = getRefraction(g, kray); 
                vPropagate(rayseq[g], -d, dIndex, surfs[j]);
            }

            if (stat[kray]==RROK)          
              stat[kray] = iRedirect(rayseq, surfs[j], j, g);   // TIR, whatever.

            vxtolab(rayseq[g], surfs[j]);  // update all coordinates; no more motions. 

            if (bBack)                     // approve inside and outside bypass but not TIR etc
            {
                if (bBypass(prev, stat[kray]))
                  stat[kray] = RROK; 
                else
                  stat[kray] = Math.max(prev, stat[kray]); // pick worse
            }

            prev = stat[kray]; 

            boolean bLoop = (stat[kray]==RROK) || (bFront && bFrontOK(stat[kray])); 
            if (!bLoop)     // bail out of surface loop
              break; 
        }

        if (RROK==stat[kray])  // update the ray table; but also in iBuildRays() ???
        {
            for (int g=0; g<=howfar[kray]; g++)
              for (int iatt=0; iatt<RNATTRIBS; iatt++)
                dRays[kray][g][iatt] = rayseq[g][iatt];
        }

        return (RROK==stat[kray]);   // return success or failure

    } //--------end of bRunOneRay()-----------------------



    private static boolean bBypass(int prev, int stat)
    //  Evaluates bypass=OK exit logic for bimodal lenses
    //  Bimodal lenses allow some specific joint ray failures.
    {
        if ((prev==RROK) && (stat==RROK))
          return true; 
        if ((prev==RRMIS) && ((stat==RRMIS) || (stat==RRBAK) || (stat==RRBO)))
          return true; 
        if ((prev==RRBAK) && ((stat==RRMIS) || (stat==RRBAK) || (stat==RRBO) || (stat==RRBI)))
          return true; 
        if ((prev==RRBI) && ((stat==RRMIS) || (stat==RRBAK) || (stat==RRBI)))
          return true; 
        if ((prev==RRBO) && ((stat==RRMIS) || (stat==RRBAK) || (stat==RRBO)))
          return true; 
        return false;
    }

    private static boolean bFrontOK(int stat)
    // provides loop permission for bimodal-front ray fail situations
    {
        switch(stat)
        {
            case  RROK:
            case  RRMIS:
            case  RRBAK:
            case  RRBI:
            case  RRBO: return true;
        }
        return false; 
    }

    private static int getBestSurf(int g)
    // For a one-surface group, returns that surface;
    // For a bigger group, returns the best surface, or -1 if none are OK.
    // This only names the best surface, does NOT propagate the winner. 
    {
        if (jstop[g] == jstart[g])
          return jstart[g]; 

        int iTrial[] = new int[MAXSURFS]; 
        double dTrial[] = new double[MAXSURFS];    
        for (int j=jstart[g]; j<=jstop[g]; j++)
        {
            labtovx(rayseq[g-1], rayseq[g], surfs[j]); 
            dTrial[j] = dIntercept(rayseq[g], surfs[j]);
            iTrial[j] = (dTrial[j]>=0.0) ? RROK : (int) (-dTrial[j]);
            if (iTrial[j]==RROK)
            {
                vPropagate(rayseq[g], dTrial[j], 1.0, surfs[j]);
                iTrial[j] = iDiams(rayseq[g], surfs[j]);    
                vPropagate(rayseq[g], -dTrial[j], 1.0, surfs[j]);
            }
        }
        int jBest = -1;   // absentee code
        double dBest = BIGVAL; 
        for (int j=jstart[g]; j<=jstop[g]; j++)
          if ((dTrial[j]>TOL) && (dTrial[j]<dBest) && (iTrial[j]==RROK))
          {
              dBest = dTrial[j];
              jBest = j;
          }

        return jBest; 
    }





    





    static public boolean bRunRandomRay()
    // This runs bRunray() whose iInitRaySeq() does the randomization.
    // Of course assumes that raystarts[] is current and correct!
    // Then this does all the WFE correction stuff. 
    // Assumes that doWFEtask() has been run, thereby building 
    // group arrays sWFE[], eWFE[], ijWFE[][], and tiltWFE[][].
    // But yikes! a random ray won't have any "group" identity since
    // it could have been randomed to any intermediate field point.
    // Ergo, no way to apply WFE correction to a random ray
    // except via start & end tilts.  May as well use kGuideRay???
    {
        int gnsurfs = DMF.giFlags[ONSURFS]; 
        int gngroups = DMF.giFlags[ONGROUPS]; 
        boolean bStatus = bRunOneRay(0); // includes iInitRaySeq()

        for (int jsurf=0; jsurf<=howfar[0]; jsurf++)
          for (int iatt=0; iatt<RNATTRIBS; iatt++)
            dRays[0][jsurf][iatt] = rayseq[jsurf][iatt]; 

        if (bStatus)          //---update WFE information------
        {
            int ig = iWFEgroup[kGuideRay];
            double dsk, dek; 
            dsk = (dRays[0][0][RX] - sWFE[ig][RX]) * dRays[0][0][RU]
                + (dRays[0][0][RY] - sWFE[ig][RY]) * dRays[0][0][RV]
                + (dRays[0][0][RZ] - sWFE[ig][RZ]) * dRays[0][0][RW];

            dek = (dRays[0][gnsurfs][RX] - eWFE[ig][RX]) * dRays[0][gnsurfs][RU]
                + (dRays[0][gnsurfs][RY] - eWFE[ig][RY]) * dRays[0][gnsurfs][RV]
                + (dRays[0][gnsurfs][RZ] - eWFE[ig][RZ]) * dRays[0][gnsurfs][RW];

            dWFE[0] = dRays[0][gnsurfs][RPATH] + dsk - dek - avgWFE[ig];

            //-------apply the tilt correction------------

            int jx = ijWFE[ig][0]; 
            int jy = ijWFE[ig][1]; 
            dWFE[0] -= tiltWFE[ig][0]
                     + tiltWFE[ig][1]*dRays[0][gnsurfs][jx]
                     + tiltWFE[ig][2]*dRays[0][gnsurfs][jy];
        }
        return bStatus; 
    }


    static public int getGroupNum(int opcode)
    // Converts a given opcode into its group number.
    // This handles the case of "final" by returning ngroups. 
    // Callers should always test this result for error situation = -1!
    { 
        int ngroups = DMF.giFlags[ONGROUPS]; 
        if (opcode < 0)
          return -1; 
        int attr = opcode % 100;
        if (attr > 20)  // eliminate RNOTE, RBUG...
          return -1; 
        int group = opcode/100; 
        if (group == RFINAL/100)  // handles "final"  
          return ngroups; 
        if (group > ngroups)
          return -1; 
        return group; 
    }
    
    static public int getAttrNum(int opcode)
    // Always test result for situation = -1!
    {
        opcode %= 100; 
        if (opcode >= RNATTRIBS) // eliminate RNOTE, RBUG...
          return -1;
        else
          return opcode; 
    }


    static public int getStatus(int kray)
    // Returns RROK or ray error code for "kray"
    {
        return stat[kray]; 
    }


    static public int getHowfarLoop(int kray)
    // Returns how far the *loop* went, 1...ngroups
    // even though the ray may have Diametered out.
    // Use this in InOut's explanations. 
    {
        return howfar[kray]; 
    } 

    static public int getHowfarRay(int kray)
    // Returns how far the *ray* went, 0....ngroups
    {
        int ngroups = DMF.giFlags[ONGROUPS]; 
        return (stat[kray] == RROK) ? ngroups : howfar[kray]-1; 
    } 
   


    static public boolean getExtend(int kray)
    // Returns true if the ray should be drawn with a dotted extension
    // True for bak, mis, Diam, diam, but not Iris, iris, spider.
    // Called by layout; loaded within local bRunray().
    {
        return bExtend[kray];
    }

    static public int getGuideRay()
    // Returns the number 1...nrays of ray whose color, wavel, order is in use.
    // Most useful for random rays, where kray=0. 
    {
        return kGuideRay;
    }


    static public double getRefraction(int jsurf, int gkray)
    // if gwave==0: Returns index approaching jsurf, using gkray @wave.
    // if gwave>0: returns intex approaching jsurf, using media @gwave.
    // Called by LayoutPanel for shading with gkray=1. 
    // Called by redirectors, below, for Snell's law and optical path.
    // gO2M[] is evaluated in DMF when parsing is complete
    // gR2M[] is evaluated in DMF when parsing is complete
    {
        // First: try to get refr from surfs[][] set by OEJIF.
        // If OK, use it; else use media LUT. 
        int nsurfs = DMF.giFlags[ONSURFS]; 
        if (jsurf<1)
          return 1.0;        // error condition
        if (jsurf > nsurfs)
          jsurf = nsurfs;   // eliminate final refraction to vacuum; A186
        double refr = surfs[jsurf][OREFRACT]; 
        if (Double.isNaN(refr))
        {
            int k = (gkray==0) ? getGuideRay() : gkray; 
            if (k<1)
              return 1.0;    // error condition; 
            int iglass = gO2M[jsurf]; 
            if (iglass<1)
              return 1.0;    // error condition
            int iwave = gR2M[k]; 
            if (gwave>0)     // global mandate to use given iwave: MPlotPanel
              iwave = gwave; 
            if (iwave<1)
              return 1.0;    // error condition
            return media[iglass][iwave]; 
        }
        if (refr == 0.0)
          refr = 1.0; 
        return refr;
    }


    static public void setEulers()
    // Generate matrix converting local to lab frame. 
    // Use transpose to convert lab frame to local. 
    // Sequence is tilt(x), pitch(y'), roll(z").
    // Called by Auto.dNudge(), OEJIF.parse(), MPlot. 
    // Used by RT13:: labtovx() and vxtolab()().
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    {
       double ct, st, cp, sp, cr, sr; 
       for (int j=1; j<=DMF.giFlags[ONSURFS]; j++)
       {
           ct = U.cosd(surfs[j][OTILT]); 
           st = U.sind(surfs[j][OTILT]); 
           cp = U.cosd(surfs[j][OPITCH]); 
           sp = U.sind(surfs[j][OPITCH]); 
           cr = U.cosd(surfs[j][OROLL]); 
           sr = U.sind(surfs[j][OROLL]);            
           surfs[j][OE11] = cr*cp;               // X <- x; M11
           surfs[j][OE12] = -sr*cp;              // X <- y; M12
           surfs[j][OE13] = sp;                  // X <- z; M13
           surfs[j][OE21] = cr*sp*st + sr*ct;    // Y <- x; M21
           surfs[j][OE22] = cr*ct - sr*sp*st;    // Y <- y; M22
           surfs[j][OE23] = -cp*st;              // Y <- z; M23
           surfs[j][OE31] = -cr*sp*ct + sr*st;   // Z <- x; M31
           surfs[j][OE32] = sr*sp*ct + cr*st;    // Z <- y; M32
           surfs[j][OE33] = cp*ct;               // Z <- z; M33
       }
    }





    /*-----------------------------------------------------------*/
    /*-------------------------private zone----------------------*/
    /*-----------------------------------------------------------*/

    private static int kGuideRay      = 0; 
    private static boolean bExtend[]  = new boolean[MAXRAYS+1]; 
    private static int stat[]    = new int[MAXRAYS+1];
    private static int howfar[]       = new int[MAXRAYS+1];
    
    private static int     jfound[][] = new int[MAXRAYS+1][MAXGROUPS+1];  
    private static double  rayseq[][] = new double[MAXGROUPS+1][RNATTRIBS];
    private static double dRays[][][] = new double[MAXRAYS+1][MAXGROUPS+1][RNATTRIBS];

    private static boolean   bUserOptionPositive = true; 
    private static int       iUserOptionMethod = 0; 
    private static double    dIsoRadius = 0.0; 
    
    /*--------------for WFE table and random-----------------*/

    private static double dWFE[]      = new double[MAXRAYS+1];      
    private static double sWFE[][]    = new double[MAXWFEGROUPS][3]; 
    private static double eWFE[][]    = new double[MAXWFEGROUPS][3]; 
    private static double avgWFE[]    = new double[MAXWFEGROUPS]; 
    private static double tiltWFE[][] = new double[MAXWFEGROUPS][3]; 
    private static int    ijWFE[][]   = new int[MAXWFEGROUPS][2];     // pupil
    
    private static int    ngood = 0; 
    
    

    static private void doWFEtask(int gngood, int gnrays, int gnsurfs)
    // Run this after each ray trace regardless of presence of WFEcolumn.
    // It computes dWFE[] using dRays[][][] data. 
    // It saves ray start sWFE[][] and ray end eWFE[][] information,
    // then evaluates the table ray WFEs, saved into dWFE[].
    // Don't bother saving into dRays[6]; save into dWFE[] only. 
    // Subsequent random rays can use sWFE & eWFE for their WFEs,
    // provided that they are organized to use kGuideRay. 
    //
    // How to apply MinFit? For each WFEgroup,
    // identify & save the pupil coord pair ijWFE[][];
    // compute & save tilts as tiltWFE[][] from MinFit. 
    // Make these available to bRunRandomRay() --line 177--- as well. 
    {
        for (int k=1; k<=gnrays; k++)
          dWFE[k] = -0.0; 

        if (gngood < 1)
          return; 

        int ngroups = DMF.giFlags[RNWFEGROUPS];

        for (int ig=0; ig<ngroups; ig++)           //---zero start & end----
        {
            for (int iatt=RX; iatt<=RZ; iatt++)
               sWFE[ig][iatt] = eWFE[ig][iatt] = 0.0; 
            ijWFE[ig][0] = 0;        // no group vars yet
            ijWFE[ig][1] = 0; 
            tiltWFE[ig][0] = 0.0;    // no tilt fit yet. 
            tiltWFE[ig][1] = 0.0;
            tiltWFE[ig][2] = 0.0;  
        } 

        for (int ig=0; ig<ngroups; ig++)           //--average start & end----
        {
            int ngg = 0;
            for (int k=1; k<=gnrays; k++)
              if (bGoodRay[k] && (ig == iWFEgroup[k]))
              {
                  sWFE[ig][RX] += dRays[k][0][RX]; 
                  sWFE[ig][RY] += dRays[k][0][RY]; 
                  sWFE[ig][RZ] += dRays[k][0][RZ]; 
                  eWFE[ig][RX] += dRays[k][gnsurfs][RX]; 
                  eWFE[ig][RY] += dRays[k][gnsurfs][RY]; 
                  eWFE[ig][RZ] += dRays[k][gnsurfs][RZ]; 
                  ngg++; 
              };
            if (ngg < 1)
            {
               continue; 
            }
            sWFE[ig][RX] /= ngg; 
            sWFE[ig][RY] /= ngg;
            sWFE[ig][RZ] /= ngg; 
            eWFE[ig][RX] /= ngg;
            eWFE[ig][RY] /= ngg;
            eWFE[ig][RZ] /= ngg;
        }

        double dsk, dek; 
        for (int k=1; k<=gnrays; k++)         //---correct each ray-----
          if (bGoodRay[k])
          {
              int ig = iWFEgroup[k]; 
              dsk = (dRays[k][0][RX]-sWFE[ig][RX])*dRays[k][0][RU]
                  + (dRays[k][0][RY]-sWFE[ig][RY])*dRays[k][0][RV]
                  + (dRays[k][0][RZ]-sWFE[ig][RZ])*dRays[k][0][RW];

              dek = (dRays[k][gnsurfs][RX]-eWFE[ig][RX])*dRays[k][gnsurfs][RU]
                  + (dRays[k][gnsurfs][RY]-eWFE[ig][RY])*dRays[k][gnsurfs][RV]
                  + (dRays[k][gnsurfs][RZ]-eWFE[ig][RZ])*dRays[k][gnsurfs][RW];

              dWFE[k] = dRays[k][gnsurfs][RPATH] + dsk - dek;
          }

        for (int ig=0; ig<ngroups; ig++)     //---average each group----
        {
            avgWFE[ig] = 0.0; 
            int ngg = 0; 
            for (int k=1; k<=gnrays; k++)
            {
                if (bGoodRay[k] && (ig == iWFEgroup[k]))
                {
                    avgWFE[ig] += dWFE[k];
                    ngg++; 
                }
            }
            if (ngg < 1)
            {
               return; 
            }
            avgWFE[ig] /= ngg; 
        }

        for (int k=1; k<=gnrays; k++)   //----subtract group average-----
          if (bGoodRay[k])
            dWFE[k] -= avgWFE[iWFEgroup[k]];

        //-----------now fit spherical wavefront to WFE------

        double rr[][] = new double[MAXRAYS][7]; 
        for (int ig=0; ig<ngroups; ig++)
        {
            int ngg = 0; 
            for (int k=1; k<=gnrays; k++)
            {
                if (bGoodRay[k] && (ig == iWFEgroup[k]))
                {
                    for (int iatt=0; iatt<6; iatt++)
                      rr[ngg][iatt] = dRays[k][gnsurfs][iatt]; 
                    rr[ngg][6] = dWFE[k]; // capture input from above
                    ngg++; 
                }
            }
            if (bGetPupil(rr, ig, ngg, ijWFE[ig]))
            {
                int jx = ijWFE[ig][0]; 
                int jy = ijWFE[ig][1]; 
                MinFit.getABC(ngg, rr, jx, jy, 6, tiltWFE[ig]);

                //---finally apply this fit to the rays-----

                for (int k=1; k<=gnrays;  k++)
                  if (bGoodRay[k] && (ig == iWFEgroup[k]))
                    dWFE[k] -= tiltWFE[ig][0]
                              + tiltWFE[ig][1]*dRays[k][gnsurfs][jx]
                              + tiltWFE[ig][2]*dRays[k][gnsurfs][jy];
            } 
        }
    } //----------finished with doWFEtable()-----------------------



    static private boolean bGetPupil(double rr[][], int g, int n, int ij[])
    // Discovers which of {xy, xz, yz, uv, uw, vw} is the pupil. 
    {
        double big[] = new double[6];
        double wee[] = new double[6]; 
        for (int i=0; i<n; i++)
        {
           if (i==0)
             for (int j=0; j<6; j++)
               big[j] = wee[j] = rr[i][j]; 
           else
             for (int j=0; j<6; j++)
             {
                if (rr[i][j] > big[j])
                  big[j] = rr[i][j]; 
                else if (rr[i][j] < wee[j])
                  wee[j] = rr[i][j]; 
             }
        }

        double range[] = new double[6]; 
        for (int j=0; j<6; j++)
          range[j] = big[j] - wee[j]; 

        double area[] = new double[6]; 
        area[0] = range[0]*range[1];  // xy 
        area[1] = range[0]*range[2];  // xz
        area[2] = range[1]*range[2];  // yz
        area[3] = range[3]*range[4];  // uv
        area[4] = range[3]*range[5];  // uw
        area[5] = range[4]*range[5];  // vw

        double abiggest=area[0];
        int    kbiggest=0; 
        for (int k=1; k<6; k++)   // search for the pupil
          if (area[k]>abiggest)
          {
             abiggest = area[k];
             kbiggest = k;
          }

        if (abiggest < TOL)     // no pupil found.
        {
            ij[0] = ij[1] = 0; 
            return false; 
        } 

        switch (kbiggest)   // decode pupil variables
        {
            case 0: ij[0]=0; ij[1]=1; return true;  
            case 1: ij[0]=0; ij[1]=2; return true; 
            case 2: ij[0]=1; ij[1]=2; return true; 
            case 3: ij[0]=3; ij[1]=4; return true; 
            case 4: ij[0]=3; ij[1]=5; return true; 
            case 5: ij[0]=4; ij[1]=5; return true; 
        }
        return false; 
    } //----completes bGetPupil()--------



    static private int iInitRaySeq(int kray, int nsurfs)
    // This moves raystarts[] into  rayseq[][].
    // It is called only from bRunray(). 
    // Constructs rayseq[j=0]: the labframe ray start for bRunray(). 
    // Its input data are the numbers in raystarts[kray].
    // Returns the value of kGuideRay employed, 1...nrays,
    // even given kray=0, where a random nonzero kray gets employed. 
    {
        //---Set up user options for this ray trace; used below-------

        bUserOptionPositive = "T".equals(DMF.reg.getuo(UO_DEF, 3)); 
        for (int i=0; i<4; i++)
          if ("T".equals(DMF.reg.getuo(UO_DEF, 5+i)))
            iUserOptionMethod = i; 
        dIsoRadius = U.suckDouble(DMF.reg.getuo(UO_DEF,9)); 
        int nrays = DMF.giFlags[RNRAYS];
        int iGroup = 0;  

        //----Clear out entire rayseq[] from previous run------
        for (int j=0; j<=MAXSURFS; j++)
        {
            for (int i=RX; i<=RTWL; i++)
              rayseq[j][i] = -0.0;
        }

        //-----set up for distributions--------------

        boolean bRandom = (kray == 0); 
        boolean bXYZcontinuous = "T".equals(DMF.reg.getuo(UO_RAND,3)); 
        boolean bUVWcontinuous = "T".equals(DMF.reg.getuo(UO_RAND,5)); 
        boolean bUniform  = "T".equals(DMF.reg.getuo(UO_RAND, 7)); 
        boolean bCosine   = "T".equals(DMF.reg.getuo(UO_RAND, 8)); 
        boolean bBell     = "T".equals(DMF.reg.getuo(UO_RAND, 9)); 
        boolean bGauss    = "T".equals(DMF.reg.getuo(UO_RAND, 10)); 
        boolean bLorentz  = "T".equals(DMF.reg.getuo(UO_RAND, 11));  
        double  dConcen   = U.suckDouble(DMF.reg.getuo(UO_RAND, 12)); 
        dConcen = Math.max(1, dConcen); 
        int which = bCosine ? 1 : bBell ? 2 : bGauss ? 3: bLorentz ? 4 : 0;  
        
        if (bRandom) // Choose a random local kray for color, wavel, order.
        {
            kray = (int) (nrays * Math.random() + 1.0); 
            iGroup = iWFEgroup[kray]; 
        }

        //----Construct the random ray values XYZUVWP here-------------
     

        int krandxyz = (int) (nrays * Math.random() + 1.0);  
        for (int i=RX; i<=RZ; i++)
        {   
            boolean bAbsent = U.isNegZero(raystarts[kray][i]); 
            if (bAbsent)  // unspecified start
              rayseq[0][i] = -0.0; 
            else if (bRandom)
            {
                if (bXYZcontinuous)
                  rayseq[0][i] = smins[iGroup][i] + getRand(which, dConcen)*spans[iGroup][i]; 
                else
                  rayseq[0][i] = raystarts[krandxyz][i]; 
            }
            else
              rayseq[0][i] = raystarts[kray][i]; 
        }  

        int kranduvw = (int) (nrays * Math.random() + 1.0);           
        for (int i=RU; i<=RW; i++)
        {   
            boolean bAbsent = U.isNegZero(raystarts[kray][i]); 
            if (bAbsent)  // unspecified start
              rayseq[0][i] = -0.0; 
            else if (bRandom)
            {
                if (bUVWcontinuous)
                  rayseq[0][i] = smins[iGroup][i] + getRand(which, dConcen)*spans[iGroup][i]; 
                else
                  rayseq[0][i] = raystarts[kranduvw][i]; 
            }
            else
              rayseq[0][i] = raystarts[kray][i]; 
        }  

        rayseq[0][RPATH] = raystarts[kray][RPATH]; 

        //-----Now have the defined rays, table or random---------
        //-----but still have -0.0 for absentee rays--------------
        //-----Fill in isotropic random direction cases next------

        if (bRandom)
        {
            double span = 1.0 - U.cosd(dIsoRadius); 
            switch(iUserOptionMethod)
            {
              case 0:  // volume  
                 break;
              case 1:  // isotropic U0 
                 {
                     double s = span * Math.random();
                     double p = U.TWOPI * Math.random(); 
                     double q = bUserOptionPositive ? 1-s : s-1; 
                     double r = Math.sqrt(1.0 - q*q); 
                     rayseq[0][RU] = q; 
                     rayseq[0][RV] = r * Math.cos(p); 
                     rayseq[0][RW] = r * Math.sin(p); 
                 }
                 break; 
              case 2:  // isotropic V0 
                 {
                     double s = span * Math.random();
                     double p = U.TWOPI * Math.random(); 
                     double q = bUserOptionPositive ? 1-s : s-1; 
                     double r = Math.sqrt(1.0 - q*q); 
                     rayseq[0][RV] = q; 
                     rayseq[0][RU] = r * Math.cos(p); 
                     rayseq[0][RW] = r * Math.sin(p); 
                 }
                 break; 
              case 3: // isotropic W0
                 {
                     double s = span * Math.random();
                     double p = U.TWOPI * Math.random(); 
                     double q = bUserOptionPositive ? 1-s : s-1; 
                     double r = Math.sqrt(1.0 - q*q); 
                     rayseq[0][RW] = q; 
                     rayseq[0][RU] = r * Math.cos(p); 
                     rayseq[0][RV] = r * Math.sin(p); 
                 }
                 break; 
             }
         }

        //---If there are still absentees {U0, V0, W0} then ----
        //---the lastAbsentAttrib will receive the makeup--------

        int lastAbsentAttrib = 0; 
        for (int i=RU; i<=RW; i++)
          if (U.isNegZero(rayseq[0][i]))
            lastAbsentAttrib = i; 

        if (lastAbsentAttrib > 0)
        // One or more absentees; fix up lastAbsentAttrib.
        // Since absentees are -0.0, no need to skip their summation.
        // Normalize later; also handles null vector case. 
        {
            double sign = bUserOptionPositive ? 1.0 : -1.0; 
            double sumsq = 0.0; 
            for (int i=RU; i<=RW; i++)
              sumsq += rayseq[0][i]*rayseq[0][i]; 
            if (sumsq <= 1.0)
              rayseq[0][lastAbsentAttrib] = sign*Math.sqrt(1-sumsq);
        }

        normalizeLab(rayseq[0]); // normalizes, repairs null vector.
        for (int i=RX; i<=RW; i++)
          if (-0.0==rayseq[0][i])
            rayseq[0][i] = 0.0;  // clean up any remaining -0.0 cases.

        return kray; 
    }

    static private double getRand(int which, double dConcen)
    // returns 0<x<1 with various distribution densities.
    // dConcen = halfspan/width50; if =1, uniform.  
    {
        double uni = Math.random(); 
        dConcen = Math.max(1, dConcen);  
        if (dConcen<1.01)
          which = 0;   // adopt uniform
        switch(which)
        {
           case 0:  return uni;                            // uniform

           case 1:  return (1/Math.PI)*Math.acos(1-2*uni); // cosine

           case 2:  return bell(uni);                      // bell

           case 3:  double sigma=0.5/(1.349*(dConcen-1));  // Gaussian
                    double x=0.5;                     
                    boolean bOut=true; 
                    while (bOut)
                      {x = 0.5+sigma*U.grand(); bOut=(x>=1.)||(x<=0.); }
                    return x; 

           case 4:  double b = 4*dConcen - 4;              // Lorentzian
                    return 0.5+(1/b)*Math.tan((2*uni-1)*Math.atan(b/2)); 

           default: return uni;
        }
    }

    static private double bell(double p)
    // Bisection solver, 0=gBell(x)-p; 0<p<1, 0<x<1.
    {
        if ((p<0) || (p>1))
          return Double.NaN; 
        double a = 0.0;          // initial bracket
        double b = 1.0;          // initial bracket
        double c = 0.5*(a+b);    // initial center
        double funa = gBell(a)-p; 
        double funb = gBell(b)-p; 
        double func = gBell(c)-p; 

        for (int reps=0; reps<10; reps++)  // ten iters; err<0.001
        {
            if (funa*funb>0.0)
              return Double.NaN; 
            if (funa*func<=0.0)  // root in {a,c}; revise b and c.
            {
                 b = c; 
                 funb = func;
                 c = 0.5*(a+b); 
                 func = gBell(c)-p; 
            }
            else  // root in {c,b}; revise a and c.
            {
                 a = c; 
                 funa = func; 
                 c = 0.5*(a+b); 
                 func = gBell(c)-p; 
            }
        }
        return c; 
    }

    static private double gBell(double x)
    // returns cumulative probability 0<g<1 given 0<x<1, for bell() solver.
    // This is pieced together from two half quintics. 
    // Its probability density is a bell curve, two half quartics.
    {
        if ((x<0) || (x>1))
          return Double.NaN;
        if ((x==0) || (x==0.5) || (x==1))
          return x; 
        boolean bLower = true; 
        if (x>0.5)
        {
            bLower = false; 
            x = 1.-x; 
        }
        double y = (40./7.)*x*x*x - (48./7.)*x*x*x*x*x; 
        return bLower ? y : 1-y; 
    } 


    static private double dGetFunc(double ray[], double surf[])
    // Called by numNorm at six points in a tiny volume around intercept. 
    // Returns z-zsurf(x,y) for a neighborhood of the surface.
    // Relies upon class Z for its surface function library. 
    {
        double xyz[] = new double[3];  
        xyz[0] = ray[RTXL]; 
        xyz[1] = ray[RTYL]; 
        xyz[2] = Z.dGetZsurf(xyz[0], xyz[1], surf); 
        return ray[RTZL] - xyz[2]; 
    }


    static private void vPropagate(double ray[], double d, double dI, double s[])
    // Extends a ray for a distance d.
    // Void because this cannot fail. 
    // Index is needed only for RPATH. 
    {
        ray[RTXL] += ray[RTUL] * d; 
        ray[RTYL] += ray[RTVL] * d; 
        ray[RTZL] += ray[RTWL] * d; 
        ray[RPATH] += dI * d;
        if (s[OTYPE] == OTDISTORT)
          ray[RPATH] -= ray[RTZL]; 
    }


    static private void vExtend(double ray[])
    // Extends a failed ray for layout dotted indicator.
    // Just like vPropagate() but used for failed rays. 
    // Extension length depends on diams of target surface.
    // Does not update ray[RPATH] nor should it. 
    {
        double d = 0.02 * DMF.getOsize(); 
        if (d<TOL)
          d = 0.01; 
        ray[RTXL] += ray[RTUL] * d; 
        ray[RTYL] += ray[RTVL] * d; 
        ray[RTZL] += ray[RTWL] * d; 
    }










    /*---------optical methods: interceptors & rootfinders--------*/
    /*---------optical methods: interceptors & rootfinders--------*/
    /*---------optical methods: interceptors & rootfinders--------*/

    static private double dIntercept(double ray[], double surf[])
    // This does not move the ray.  Instead, if OK, recommends d>=0;
    // RAY length = ZERO is VALID for plane surfaces;  (exactly zero? slightly negative?)
    // RAY length = ZERO is INVALID for curved surfaces. 
    // vPropagate() is called later if decision after Diams = GO.
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // Return values: RROK, -RRMIS, -RRBAK, -RRDIA, -RRSPI, etc 
    {
        int iType = U.getInt(surf[OTYPE]);
        double dpro = surf[OPROFILE]; 
        int profile = U.getInt(dpro); 

        boolean bArray = ((iType==OTLENSARRAY) || (iType==OTMIRRARRAY)); // irisarray?
        double d = 0.0; 
        if (iType == OTIRISARRAY)
          d = dPlaneSolve(ray, surf); 
        else if (iType == OTCBOUT)
          d = 0.0;         
        else switch(profile)
        {
           case OSPLANO:   d = dPlaneSolve(ray, surf); break;
           case OSCONIC:
           case OSCONICLT:
           case OSCONICGT:
           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:
           case OSYCYL:
           case OSYCYLLT:
           case OSYCYLGT:  if (bArray)
                             d = dArrayQuadSolve(ray, surf);
                           else
                             d = dQuadSolve(0, 0, ray, surf);
                           break;
           case OSTORIC:
           case OSPOLYREV:
           case OSZERNREV:
           case OSZERNTOR: 
           case OSBICONIC: d = dNumSolve(ray, surf); 
                           break;
        }
        if (Math.abs(d) < TOL)
          d = 0.0;
        return d; 
    }


    static private double dPlaneSolve(double ray[], double surf[])
    // Returns -RRMIS if ray is parallel to surface.
    // Returns -RRBAK if intercept is *definitely* backwards. 
    // ZERO=VALID is OK here. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2005, 2010
    {
        if (Math.abs(ray[RTWL]) < TOL)
          return -RRMIS;            // negative code 
        double d = -ray[RTZL] / ray[RTWL]; 
        if (d < -TOL)
          return -RRBAK;
        if (d < TOL)
          return 0.0;
        return d; 
    }


    static private double dQuadSolve(double arrayox, double arrayoy, 
                              double ray[], double surf[])
    // Returns real positive root, or negative code number for failure. 
    // Handles conic, xcylinder, ycylinder cases, hints LT/GT/none.
    // ray[] is a 13-element array describing the ray start.
    // surf[] is a 122 parameter surface description
    // Offsets within an array: arrayox, arrayoy; zero for a single surface
    // Intercept policy from opro = surfs[OPROFILE] cases ">", "<" etc. 
    // ZERO=INVALID implemented here; permits SKIP.OPT
    // Rejects phantom hyperboloids and farside ellipsoids. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2007, 2012
    // Returns error codes -RRMIS, -RRBAK, -RRDIA, -RRSPI, ...
    {
        double c, s, x, y, z, u, v, w, d;
        double[] dd = new double[2]; 
        double abc[] = new double[3]; 
        String report = ""; 

        //---initialize local shorthand variables-----------

        s = surf[OASPHER] + 1.0; 
        x = ray[RTXL] + arrayox;
        y = ray[RTYL] + arrayoy;
        z = ray[RTZL];
        u = ray[RTUL];
        v = ray[RTVL];
        w = ray[RTWL];

        int opro = (int) surf[OPROFILE]; 
        switch(opro)
        {
           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:  
               c = surf[OCURVX]; break; 
           default:        
               c = surf[OCURVE]; break; 
        } 

        //----------set up the appropriate quadratic form------

        switch(opro)
        {
           case OSCONIC:
           case OSCONICLT:
           case OSCONICGT:
                abc[0] = c*(u*u+v*v+s*w*w);
                abc[1] = 2*c*(x*u+y*v+s*z*w)-2*w;
                abc[2] = c*(x*x+y*y+s*z*z)-2*z;
                break; 

           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:
                abc[0] = c*(u*u+w*w);
                abc[1] = 2*c*(x*u+z*w)-2*w;
                abc[2] = c*(x*x+z*z)-2*z;
                break; 

           case OSYCYL:
           case OSYCYLLT:
           case OSYCYLGT:
                abc[0] = c*(v*v+s*w*w);
                abc[1] = 2*c*(y*v+s*z*w)-2*w;
                abc[2] = c*(y*y+s*z*z)-2*z;
                break; 
        }

        //-------get positive roots and test them-------------

        int nroots = iGetPosRoots(abc, dd); 

        double  cz0 = c*(z+w*dd[0]);   // vxframe departure from plano
        double  cz1 = c*(z+w*dd[1]);   // vxframe departure from plano
        boolean E0  = s*cz0 < 1.0;     // existence check
        boolean E1  = s*cz1 < 1.0;     // existence check

        switch (nroots)
        {
            case -1:            // no real roots whatsoever
              return -RRMIS;    // negative error code

            case 0:             // no positive path roots
              return -RRBAK;    // negative error code

            case 1:            // one positive path root
              if (E0)  
                return dd[0];  //  Diameter test comes later
              else
                return -RRMIS;  // negative error code

            case 2:            // two positive path roots
              if (E0 && !E1)
                return dd[0];  // Diameter test immediately below
              if (!E0 && E1)
                return dd[1];  // Diameter test immediately below
              if (!E0 && !E1)
                return -RRMIS;  // negative error code
  
              //----both roots exist; test Diameters----------
              
              int D0 = testDiameter(dd[0], ray, surf); // RROK=0 or RRDIA, RRSPI, ...
              int D1 = testDiameter(dd[1], ray, surf); // RROK=0 or RRDIA, RRSPI, ...
              
              if ((D0==RROK) && (D1!=RROK))  // one good intercept
                return dd[0]; 
              if ((D0!=RROK) && (D1==RROK))  // other good intercept
                return dd[1]; 
              if ((D0!=RROK) && (D1!=RROK))  // no good intercepts
                return -D0;   // return a negative error code
              
              if ((D0==RROK) && (D1==RROK))
                switch(opro)   // both roots are good so pick the preferred one
                {
                   case OSCONICGT:
                   case OSXCYLGT:   
                   case OSYCYLGT: return Math.max(dd[0], dd[1]);    // longer path

                   case OSCONICLT:
                   case OSXCYLLT:
                   case OSYCYLLT: return (cz0<cz1) ? dd[0] : dd[1]; // closer to vertex
                 
                   default:       return Math.min(dd[0], dd[1]);    // shorter path      
                }  
        }
        return -RRMIS;  // SNH; moved here thanks to Xlint 8 OCt 2014
    } //----------end dQuadsolve()--------------------


    static private int testDiameter(double d, double ray[], double surf[])
    // sets up a trial ray and returns an opinion from iDiams()
    // Returns RROK, RRDIA, RRIRI, RRSPI, etc
    {
        double trial[] = new double[13]; 
        for (int i=0; i<13; i++)
          trial[i] = ray[i]; 
        trial[RTXL] += trial[RTUL]*d; 
        trial[RTYL] += trial[RTVL]*d;
        trial[RTZL] += trial[RTWL]*d; 
        return iDiams(trial, surf); 
    }
    
    
    

    static private double dArrayQuadSolve(double ray[], double surf[])
    // Returns error codes -RRMIS, -RRBAK
    {
        double dx = surf[OODIAX]; 
        double dy = surf[OODIAY]; 
        int nx = (int) surf[ONARRAYX]; 
        int ny = (int) surf[ONARRAYY]; 
        if ((dx<=TOL) || (dy<=TOL) || (nx<1) || (ny<1))
        {
            return -RRMIS;
        } 
        double px = dx/nx;
        double py = dy/ny;
        double dBest = 9E99, dTest = -1.0;  
        int ix=0, iy=0; 
        for (int i=0; i<nx; i++)
        {
            double ox = (1.0-nx)*dx/(2.0*nx) + i*px; 
            for (int j=0; j<ny; j++)
            {
                double oy = (1.0-ny)*dy/(2.0*ny) + j*py; 
                dTest = dQuadSolve(ox, oy, ray, surf);
                if (dTest>0.0)
                {
                   double xx = ray[RTXL] + dTest*ray[RTUL]; 
                   double yy = ray[RTYL] + dTest*ray[RTVL]; 
                   boolean bCell = ((Math.abs(xx+ox) <= 0.5*px+TOL)
                                  && (Math.abs(yy+oy) <= 0.5*py+TOL)); 
                   if (bCell && (dTest<dBest))
                     dBest = dTest; 
                }
            }
        }     
        if (dBest>1E99)
          return -RRMIS;
        return dBest;  
    }



    static private double dNumSolve(double ray[], double surf[])
    // Returns propagation length if OK, else -1.0.
    // Relies upon Z.vGetZsurf() for the surface model. 
    // How to manage HINT for best efficiency?
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2005
    // Error: -RRBAK
    {
        double d[] = new double[2]; 
        if (bBracket(d, ray, surf))
        { 
            iBrent(d, ray, surf); 
            return d[0];
        }
        return -RRBAK;  // bracket fail is usually due to backward ray 
    }



    private static boolean bBracket(double d[], double r[], double s[])
    {
        int MAXIT1 = 10;       // allowed initial iterations for d[0]
        int MAXIT2 = 200;      // allowed fine iterations for d[1]
        double TINY = 1E-8;    // tiny compared to problem scale
        double FAST = 10.0;    // fast growth for d[0]
        double SLOW = 1.1;     // finesse d[1]; 1.1^200=>{1E-4,1E+4}
        double fa = 0.0; 

        //---- first, find d[0]: func(d[0]) is nonzero---------------

        d[0] = 0.0;            // initial guess
        int niter = 1; 
        while ((Math.abs(fa = zDiff(d[0],r,s)) < TOL) && (niter<MAXIT1))
        {
            niter++; 
            d[0] += TINY + FAST*d[0]; 
        }
        if (Math.abs(fa) < TOL)
        {
            return false;   
        }

        //----Then get d[1] alternating search around hint---
        //----Reject f(d[1])=0: could be a math failure----

        double hint = getHint(r); 
        d[1] = hint; 
        double p; 
        niter = 1; 
        while (((p = fa*zDiff(d[1],r,s)) >= 0.0) && (niter<MAXIT2))
        {
            niter++; 
            int j = (niter%2 == 0) ? niter/2 : -niter/2; 
            d[1] = hint * Math.pow(SLOW, j);  
        }
        if (p < 0)
          return true; 
        return false;        // failed to complete bracket. 
    } 


    static private double getHint(double ray[])
    {
        double d2 = ray[RTXL]*ray[RTXL] 
                  + ray[RTYL]*ray[RTYL] 
                  + ray[RTZL]*ray[RTZL]; 
        return 0.2*DMF.getOsize() + 0.8*Math.sqrt(d2);
    }



    private static int iBrent(double t[], double ray[], double surf[])
    //  Given a bracket (t[0], t[1]), Brent() sets t[0] to root,
    //  and returns the number of calls to zDiff() taken.
    //  Relies upon Z.vGetZsurf() for the surface model. 
    //  Press et al NUMERICAL RECIPES IN C 2nd edition 1992 p.361
    //  R.P.Brent ALGORITHMS... Prentice-Hall, NJ 1973.
    {
        int MAXIT = 50; 
        double a, b, c, d=0, e=0, min1, min2;
        double fc, p, q, r, s, toler, xm, fa, fb;
        a=t[0]; 
        b=c=t[1];
        fa=zDiff(a, ray, surf);
        fb=zDiff(b, ray, surf);
        if (fa*fb > 0)
          return -1; // bad starting bracket
        fc = fb;
        for (int iter=1; iter<MAXIT; iter++)
        {
            if (fb*fc > 0)
            {
                c = a;
                fc = fa;
                e = d = b-a;
            }
            if (Math.abs(fc) < Math.abs(fb))
            {
                a = b;
                b = c;
                c = a;
                fa = fb;
                fb = fc;
                fc = fa;
            }
            toler = 2.0 * TOL * Math.abs(b) + TOL;
            xm = 0.5*(c-b);
            t[0] = b;     // return value
            if ((Math.abs(xm) <= toler) || (fb == 0.0))
              return iter;
            if ((Math.abs(e) >= toler) && (Math.abs(fa) > Math.abs(fb)))
            {
                s = fb/fa;
                if (a == c)
                {
                    p = 2.0*xm*s;
                    q = 1.0-s;
                }
                else
                {
                    q = fa/fc;
                    r = fb/fc;
                    p = s*(2.0*xm*q*(q-r) - (b-a)*(r-1.0));
                    q = (q-1.0)*(r-1.0)*(s-1.0);
                }
                if (p > 0.0)
                  q = -q;
                p = Math.abs(p);
                min1 = 3.0*xm*q - Math.abs(toler*q);
                min2 = Math.abs(e*q);
                if (2.0*p < (min1 < min2 ? min1 : min2))
                {
                    e = d;
                    d = p/q;
                }
                else
                {
                    d = xm;
                    e = d;
                }
            }
            else
            {
                d = xm;
                e = d;
            }
            a = b;
            fa = fb;
            if (Math.abs(d) > toler)
              b += d;
            else
              b += (xm > 0.0) ? Math.abs(toler) : -Math.abs(toler);
            fb = zDiff(b, ray, surf);
        }
        return MAXIT; // SNH
    }


    static private double zDiff(double d, double ray[], double surf[])
    // This is the engine that is called by bBracket() and iBrent().
    // Returns the z-component of discrepancy ray-surface.
    // Relies upon Z.vGetZsurf() for the surface model. 
    {
        double xyz[] = new double[3]; 
        xyz[0] = ray[RTXL] + ray[RTUL]*d; 
        xyz[1] = ray[RTYL] + ray[RTVL]*d; 
        xyz[2] = Z.dGetZsurf(xyz[0], xyz[1], surf); 
        return ray[RTZL] + ray[RTWL]*d - xyz[2];
    }



    /*--------------------Diameters and iris-------------------*/
    /*--------------------Diameters and iris-------------------*/
    /*--------------------Diameters and iris-------------------*/


    static private int iDiams(double ray[], double surf[])
    // Returns RROK if ok, else a positive failure code RRDIA, RRiri, etc.
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2013
    {
        boolean bIris = (OTIRIS == surf[OTYPE]);

        boolean bIRect = ((OFIRECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        boolean bORect = ((OFORECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        
        if (OTIRISARRAY == surf[OTYPE])
          return iIrisArray(ray, surf); 

        //---do the inner edge first-------
        
        double x = ray[RTXL] - surf[OFFIX];  // eccentric frame
        double y = ray[RTYL] - surf[OFFIY];  // eccentric frame
        double diay = surf[OIDIAY]; 
        double diax = surf[OIDIAX]; 

        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            
            // if both are too small, we fall into the hole:
            
            boolean bhole = bIRect ? Math.max(sx,sy)<1.0 : sx+sy<1.0;
            if (bhole)
              return bIris ? RRiri : RRdia;    
        }

        //-----do the outer edge--------
        
        x = ray[RTXL] - surf[OFFOX];  // eccentric frame
        y = ray[RTYL] - surf[OFFOY];  // eccentric frame
        diay = surf[OODIAY]; 
        diax = surf[OODIAX]; 
        if (U.isNegZero(diax))
          diax = diay; 
        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            
            // if either is too big, we fall off the edge:

            boolean bedge = bORect ? Math.max(sx,sy)>1.0 : sx+sy>1.0;
            if (bedge)
              return bIris ? RRIRI : RRDIA;
        }

        // Now do the spider legs in X,Y plane
        // Leg zero lies along the X axis.  
        // We rotate the ray, not the rectangle.
        int nlegs = (int) surf[ONSPIDER];
        if (nlegs > 0)
        {
            double halfleg = 0.5 * surf[OWSPIDER]; 
            double radius = Math.sqrt(x*x + y*y); 
            if (radius < halfleg)
              return RRSPI; 
            double angle = Math.atan2(y, x);
            double dangle = TWOPI/nlegs; 
            while (nlegs > 0)
            {
                x = radius * Math.cos(angle); 
                y = radius * Math.sin(angle); 
                if ((x>0.0) && (Math.abs(y)<halfleg))
                  return RRSPI; 
                nlegs--; 
                angle += dangle; 
            }
        }
        return RROK; 
    }



    static private int iIrisArray(double ray[], double surf[])
    // Returns RROK or RRIRI or RRDIA.
    // Model: infinite plane barrier with holes.
    //    ** Within Rinner, ray passes with  RROK;
    //    ** Beyond Router, ray dies with RRDIA;
    //    ** In between, ray dies with RRiri.
    // M.Lampton STELLAR SOFTWARE (C) 2007
    {
        boolean bIRect = ((OFIRECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        boolean bORect = ((OFORECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));

        // do the outer edge first
        double x = ray[RTXL] - surf[OFFOX];  // eccentric frame
        double y = ray[RTYL] - surf[OFFOY];  // eccentric frame
        double diay = surf[OODIAY]; 
        double diax = surf[OODIAX]; 
        if (U.isNegZero(diax))
          diax = diay; 
        if ((diax > TOL) && (diay > TOL))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            // if either is too big, we bypass the outer edge:
            if (bORect && (Math.max(sx, sy) > 1.0))
              return RRDIA; 
            if (!bORect && (sx + sy > 1.0))
              return RRDIA; 
        }

        // inner edge next; but use Outer Offsets. 

        x = Z.dSawtoothX(x, surf); 
        y = Z.dSawtoothY(y, surf); 

        diay = surf[OIDIAY];   // inner diam
        diax = surf[OIDIAX];   // inner diam
        if (U.isNegZero(diax)) 
          diax = diay; 

        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            // if either is too big, we hit the mask:
            if (bIRect && (Math.max(sx, sy) > 1.0))
              return RRiri; 
            if (!bIRect && (sx + sy > 1.0))
              return RRiri;  
        }
        return RROK; 
    }













    /*-------------------------redirectors----------------------*/
    /*-------------------------redirectors----------------------*/
    /*-------------------------redirectors----------------------*/


    static private int iRedirect(double rayseq[][], double surf[], int j, int g)
    // M.Lampton STELLAR SOFTWARE (C) 2013
    //
    // Modifies the local-frame u,v,w to redirect this ray. 
    // Receives jsurf needed for getRefraction() towards next surface.
    // Works entirely in the local frame. 
    // Requires group "g" to properly index rayseq[]
    // Receives status from preceding Diam() check. 
    // Returns RROK, RRUNK, RRORD, RRTIR. 
    {
        vSetAngle(rayseq[g], surf);  // sets incoming RTANGLE fields before modifying ray direction
        boolean bGroovy = surf[OGROOVY] != 0.0; 
        int surftype = (int) surf[OTYPE]; 
        switch(surftype)
        {
             case OTBLFRONT:      // successful refraction at bimodal lens
             case OTBLBACK:
                    return iTG(rayseq[g], surf, j); 
             case OTDISTORT:
                    return RROK; 
             case OTIRIS: 
             case OTIRISARRAY:
                    return RROK; // no redirection needed.  
             case OTRETRO: 
                    return iRetro(rayseq[g], surf); 
             case OTMIRROR:
             case OTMIRRARRAY:
                    if (bGroovy) 
                      return iRgrating(rayseq[g], surf);
                    else
                      return iMirror(rayseq[g], surf); 
             case OTLENS:
             case OTLENSARRAY:
                    return iTG(rayseq[g], surf, j); 
             case OTSCATTER:
                    return iScatter(rayseq[g], surf); 
             case OTCBIN:  // CoordBreak input surface
                    return iCBIN(rayseq, surf, g);  // copy previous local uvw
             case OTCBOUT: // CoordBreak output surface 
                    return iCBOUT(rayseq, surf, g); // copy previous local xyzuvw
             case OTTHIN:
                    return iThin(rayseq[g],surf);
        }
        return RRNON; 
    }
    
    
        
    static private int iCBIN(double rayseq[][], double surf[], int g)
    // CoordBreak CBin input surface method
    // Must do nothing: CBout will grab local coords here.
    {
        return RROK; 
    }
    
    static private int iCBOUT(double rayseq[][], double surf[], int g)
    // CoordBreak CBout output surface method
    // Must copy previous local xyzuvw into this local surface.
    {
        if (g>1)
        {
            rayseq[g][RTXL] = rayseq[g-1][RTXL]; 
            rayseq[g][RTYL] = rayseq[g-1][RTYL]; 
            rayseq[g][RTZL] = rayseq[g-1][RTZL]; 
            rayseq[g][RTUL] = rayseq[g-1][RTUL]; 
            rayseq[g][RTVL] = rayseq[g-1][RTVL]; 
            rayseq[g][RTWL] = rayseq[g-1][RTWL]; 
        }
        return RROK; 
    }

    static private int iThin(double ray[], double surf[])
    // CoordBreak CBout output surface method
    // Must copy previous local xyzuvw into this local surface.
    {
      double focal = surf[OFOCAL];
      double mx, my;
      mx = focal * ray[RTUL] / Math.sqrt(1 - Math.pow(ray[RTUL], 2));
      my = focal * ray[RTVL] / Math.sqrt(1 - Math.pow(ray[RTVL], 2));
      ray[RTUL] = (mx - ray[RTXL]) / Math.sqrt(Math.pow(focal, 2) + Math.pow((mx - ray[RTXL]), 2));
      ray[RTVL] = (my - ray[RTYL]) / Math.sqrt(Math.pow(focal, 2) + Math.pow((my - ray[RTYL]), 2));
      ray[RTWL] = Math.sqrt(1 - Math.pow(ray[RTUL], 2) - Math.pow(ray[RTVL], 2));
      return RROK; 
    }

    static private int iMirror(double ray[], double surf[])
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // method: r = i - 2 (i dot n) n
    // note this is quadratic in n, hence independent of sign(n)
    {
        double[] Norm = new double[RNATTRIBS];
        vGetPerp(ray, surf, Norm); 
        double dotin = ray[RTUL]*Norm[RTUL] + ray[RTVL]*Norm[RTVL] + ray[RTWL]*Norm[RTWL];
        ray[RTUL] -= 2.0 * dotin * Norm[RTUL];
        ray[RTVL] -= 2.0 * dotin * Norm[RTVL];
        ray[RTWL] -= 2.0 * dotin * Norm[RTWL];
        // normalize(ray);   // should be unnecessary!
        return RROK;
    }


    static private void vSetAngle(double ray[], double surf[])
    // M.Lampton STELLAR SOFTWARE (C) 2015
    // uses iMirror() tools to get any intercept ray dot normal.
    // called by iRedirect for good rays, fills in ray[RTANGLE] and normal {i,j,k}.
    // Oct 2015: now using Triple::getAngle() full accuracy. 
    {
        double[] nor = new double[RNATTRIBS];
        vGetPerp(ray, surf, nor); 
        Triple R = new Triple(ray[RTUL], ray[RTVL], ray[RTWL]); 
        Triple N = new Triple(nor[RTUL], nor[RTVL], nor[RTWL]); 
        double degrees = Math.toDegrees(Triple.getAngle(R, N));
        if (degrees > 90.0)            // if farside
          degrees = 180.0 - degrees;   // use nearside
        // finally, fill in the angle fields of ray[]
        ray[RTANGLE] = degrees; 
        ray[RTNORMX] = nor[RTUL]; 
        ray[RTNORMY] = nor[RTVL]; 
        ray[RTNORMZ] = nor[RTWL]; 
    }

    
    static private int iRetro(double ray[], double surf[])
    {
        ray[RTUL] *= -1.0; 
        ray[RTVL] *= -1.0; 
        ray[RTWL] *= -1.0; 
        return RROK; 
    }
    

    static private int iSnell(double ray[], double surf[], int jsurf)
    // Caution: ray[13] is solved in local frame. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // Method: S' = mu * Salongsurface + gamma * Normaltosurface,
    //   where mu = Nin/Nout; and gamma completes the square. 
    // Spencer & Murty JOSA 52#6 672 1962.
    // Refractive indices can be positive or negative.
    {
        double numer, denom, mu, ax, ay, az, bx, by, bz, b2, gamma, dotin;

        int kray = getGuideRay(); 
        numer = getRefraction(jsurf, kray); 
        denom = getRefraction(jsurf+1, kray); 

        if (Double.isNaN(numer) || (numer==0.0))
          numer = 1.0; 
        if (Double.isNaN(denom) || (denom==0.0))
          denom = 1.0; 

        mu = numer/denom;
        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        /// A is mu * (ray cross norm), perpendicular to {S,N} plane
        ax = mu * (ray[RTVL]*Norm[RTWL] - ray[RTWL]*Norm[RTVL]);  
        ay = mu * (ray[RTWL]*Norm[RTUL] - ray[RTUL]*Norm[RTWL]); 
        az = mu * (ray[RTUL]*Norm[RTVL] - ray[RTVL]*Norm[RTUL]); 

        // B is (N cross A) = mu*ray projected along surface, in {S,N} plane
        bx = Norm[RTVL]*az - Norm[RTWL]*ay;  
        by = Norm[RTWL]*ax - Norm[RTUL]*az; 
        bz = Norm[RTUL]*ay - Norm[RTVL]*ax;

        b2 = bx*bx + by*by + bz*bz;
        if (b2 > 1.0)
          return RRTIR;
        if (b2  < 1.0)
          gamma = Math.sqrt(1 - b2);
        else
          gamma = 0.0;
        dotin = ray[RTUL]*Norm[RTUL] + ray[RTVL]*Norm[RTVL] + ray[RTWL]*Norm[RTWL];
        if (dotin < 0.0)
          gamma = -gamma;
        ray[RTUL] = bx + gamma * Norm[RTUL];
        ray[RTVL] = by + gamma * Norm[RTVL];
        ray[RTWL] = bz + gamma * Norm[RTWL];
        return RROK;
    }


    static private int iTG(double ray[], double surf[], int jsurf)
    // Transmission grating solver: refraction and diffraction combined.
    // Must have numerical wavelength not literal if using diffraction. 
    //
    // Could replace iSnell() !
    //
    // Has VPHs but excludes HOEs.
    // M.Lampton STELLAR SOFTWARE (C) 2015  rev A186
    // Spencer & Murty JOSA 52#6 672 (1962) eqn 49, three terms in local frame
    // Refraction of incoming ray S...
    //    S' = (n2/n1)*S 
    // plus diffraction into the local P direction perp to grooves...
    //    + (M*G*lambda/n2)*P 
    // plus a normal part to complete the square...
    //    + gamma*r. 
    // Note: bGroovy triggers for any param GX....ORDER..VLS.....HOELAM being present. 
    //
    // Refractive indices can be positive or negative.
    {   
        int kray = getGuideRay(); 
        double numer = getRefraction(jsurf, kray); 
        double denom = getRefraction(jsurf+1, kray); 

        if (Double.isNaN(numer) || (numer==0.0))
          numer = 1.0; 
        if (Double.isNaN(denom) || (denom==0.0))
          denom = 1.0; 

        double mu = numer/denom;
        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        /// PART ONE: evaluate the refraction perp to Norm:
        
        Triple Ray   = new Triple(ray[RTUL],  ray[RTVL],  ray[RTWL]); 
        Triple Unorm = new Triple(Norm[RTUL], Norm[RTVL], Norm[RTWL]); 
        // unit length guaranteed by Z.normalize()
          
        Triple Total = Triple.getPerp(Ray, Unorm);       // pure refraction so far
        Total = Triple.getProduct(Total, mu);           // modified by refractive ratio

        /// PART TWO: evaluate the local plane diffraction if any:
        
        // Get order from raystart, or if absent, from the optic table. 
        double order = surf[OORDER]; 
        double rayorder = raystarts[kray][RSORDER]; 
        if (!U.isNegZero(rayorder))
          order = rayorder;
        if (order != 0)                // diffractive?
        {
            double wavel = raystarts[kray][RSWAVEL]; 
            if (Double.isNaN(wavel))
              return RRUNK; 
            double waveorder = wavel*order; 
            
            double gx = surf[OGX];     // density in vertex frame
            double gy = surf[OGY];     // density in vertex frame            
            
            if (waveorder != 0.)                      // and wavy?
            {
                if (Math.abs(gx) > TOL)               // add VLS in vertex frame...            
                  gx += ray[RTXL] * (surf[OVLS1]
                     + ray[RTXL] * (surf[OVLS2]
                     + ray[RTXL] * (surf[OVLS3]
                     + ray[RTXL] * surf[OVLS4])));
                else if (Math.abs(gy) > TOL)
                  gy += ray[RTYL] * (surf[OVLS1]
                     + ray[RTYL] * (surf[OVLS2]
                     + ray[RTYL] * (surf[OVLS3]
                     + ray[RTYL] * surf[OVLS4])));        
                     
                if (Math.abs(surf[OHOELAM]) > TOL)    // add HOE terms.....
                {
                    double d1 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX1])
                                          + U.sqr(ray[RTYL] - surf[OHOEY1])
                                          + U.sqr(ray[RTZL] - surf[OHOEZ1]));
 
                    double d2 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX2])
                                          + U.sqr(ray[RTYL] - surf[OHOEY2])
                                          + U.sqr(ray[RTZL] - surf[OHOEZ2]));

                    if ((d1 > TOL) && (d2 > TOL))
                    {
                        double a1 = 1.0 / (d1*surf[OHOELAM]);     // virtual HOE if <0
                        double a2 = 1.0 / (d2*surf[OHOELAM]);
                        gx += a1*(ray[RTXL]-surf[OHOEX1])-a2*(ray[RTXL]-surf[OHOEX2]);
                        gy += a1*(ray[RTYL]-surf[OHOEY1])-a2*(ray[RTYL]-surf[OHOEY2]);
                    }
                }                     
                          
                Triple Grating = new Triple(gx, gy, 0.);           // in vertex frame
                Triple Diffract = Triple.getPerp(Grating, Unorm);  // in vertex frame
                double coef = waveorder/denom;                     // scaling factor
                Grating = Triple.getProduct(Grating, coef);        // in vertex frame
                Total = Triple.getSum(Total, Grating);             // now with diffraction if present.  
            }
        }
        
        // The gamma term to make |S|=1 is purely along the normal.
        // The S components from refraction and diffraction are purely perp normal.
        // So THERE IS NO NEED FOR A NUMERICAL GAMMA SOLVER, just apply total squares,
        // to make the magnitude of S come out to equal 1.
        //
        ///// NOW MODIFY THE RAY DIRECTION IN FULL 3D ///
        
        double rlength = Total.getLength(); 
        double r2 = rlength*rlength; 
        if (r2 > 1.0)
          return RRTIR;  // could also be RRORDER
        double gamma = Math.sqrt(1 - r2); 
        double dotin = Triple.getDot(Ray, Unorm); 
        if (dotin < 0.0)
          gamma = -gamma;
        ray[RTUL] = Total.getX() + gamma * Unorm.getX();
        ray[RTVL] = Total.getY() + gamma * Unorm.getY();
        ray[RTWL] = Total.getZ() + gamma * Unorm.getZ();  
        return RROK;
    }




    static private int iScatter(double ray[], double surf[])
    {
        double radians = (Math.PI/180.0) * surf[OSCATTER]; 
        ray[RTUL] += radians * U.grand(); 
        ray[RTVL] += radians * U.grand();
        ray[RTWL] += radians * U.grand();  
        double sum = U.sqr(ray[RTUL]) + U.sqr(ray[RTVL]) + U.sqr(ray[RTWL]); 
        sum = Math.sqrt(sum); 
        ray[RTUL] /= sum;  
        ray[RTVL] /= sum; 
        ray[RTWL] /= sum;
        return RROK; 
    }
    

    static private int iRgrating(double ray[], double surf[])
    {
        return iGrating(ray, surf, true); 
    }


    static private int iGrating(double ray[], double surf[], boolean bRefl)
    // Vacuum diffraction grating, transmission or reflection. 
    //   Output: revised ray[] directions in local vertex frame.
    //   Method: Spencer & Murty eqns 49 & 50.
    //
    // Given incident propagator Ki and emergent propagator Ke,
    // boundary condition sets two wave matching conditions. {x,y} are in surface:
    //      Kxe = Kxi + 2pi*order*gx
    //      Kye = Kyi + 2pi*order*gy
    // and wave frequency match sets....
    //     |Ke| = |Ki|*v1/v2 = |Ki|*n2/n1.
    //
    // May 2013: better is to include S&M's refraction.  Unit ray directions S1, S2:
    //      S2 x Normal = (n1/n2)* S1 x Normal + M*G*lambda**Q/n2
    // where Q is the unit vector parallel to local rulings. 
    // Sept 2015 A186 doing this implementation
    //
    //
    // Let P, Q, R be unit vectors: perp groove, along groove, local normal;
    // let iP, iQ, iR be incident ray direction,
    // let eP, eQ, eR be emergent ray direction,
    // then  eP = iP - order * lambda * g;
    // and   eQ = iQ;
    // then  eR must complete the trio, making |e|=1
    //     sign(eR) = sign(iR) for transmission
    //     sign(eR) = -sign(iR) for reflection.
    // The sign of "order" depends on the sign of P adopted.  Here,
    // I use Px<0 if Gx>0 and Py<0 if Gy>0, so that positive order
    // corresponds to decreasing eP, increasing eU and increasing eV.
    // 
    // Holographic optical elements (HOEs) are computed the same way as
    // classical gratings, except the local groove frequency vector gx gy gz
    // is computed from grad(PathDifference)/HOELambda, using the fact that
    // when the path difference is an integer number of lambda we have local
    // constructive interference and a groove, but when it is a fraction
    // of a wavelength we have destructive interference and no groove. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    {
        double qx, qy, qz, qq, absRxG, px, py, pz, sp, sq, sr, sr2;
        double gx, gy, diffract, a1, a2, d1, d2;
        double dAction = bRefl ? -1.0 : 1.0; // -1=reflect; +1=transmit VACUUM ONLY

        // Get the ray wavelength from this raystart. 

        int kray = getGuideRay(); 
        double wavel = raystarts[kray][RSWAVEL]; 
        if (Double.isNaN(wavel))
          return RRUNK; 

        // Get the diffraction order from this raystart,
        // or if absent, from the optic table. 
        double order = surf[OORDER]; 
        double rayorder = raystarts[kray][RSORDER]; 
        if (!U.isNegZero(rayorder))
          order = rayorder;

        if (wavel*order == 0.0)
        {
            if (bRefl)
              return iMirror(ray, surf);
            else
              return RROK;
        }
   
        gx = surf[OGX];
        gy = surf[OGY];

        if (Math.abs(gx) > TOL)              // add VLS terms....            
          gx += ray[RTXL] * (surf[OVLS1]
              + ray[RTXL] * (surf[OVLS2]
              + ray[RTXL] * (surf[OVLS3]
              + ray[RTXL] * surf[OVLS4])));
        else if (Math.abs(gy) > TOL)
          gy += ray[RTYL] * (surf[OVLS1]
              + ray[RTYL] * (surf[OVLS2]
              + ray[RTYL] * (surf[OVLS3]
              + ray[RTYL] * surf[OVLS4])));

        if (Math.abs(surf[OHOELAM]) > TOL)    // add HOE terms.....
        {
            d1 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX1])
                           + U.sqr(ray[RTYL] - surf[OHOEY1])
                           + U.sqr(ray[RTZL] - surf[OHOEZ1]));
 
            d2 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX2])
                           + U.sqr(ray[RTYL] - surf[OHOEY2])
                           + U.sqr(ray[RTZL] - surf[OHOEZ2]));

            if ((d1 > TOL) && (d2 > TOL))
            {
                a1 = 1.0 / (d1*surf[OHOELAM]);  // virtual HOE if <0
                a2 = 1.0 / (d2*surf[OHOELAM]);
                gx += a1*(ray[RTXL]-surf[OHOEX1])-a2*(ray[RTXL]-surf[OHOEX2]);
                gy += a1*(ray[RTYL]-surf[OHOEY1])-a2*(ray[RTYL]-surf[OHOEY2]);
                // gz += a1*(ray[RTZL]-surf[OHOEZ1])-a2*(ray[RTZL]-surf[OHOEZ2]);
            }
        }

        // Get the unit groove vector Q in vertex coords.
        // Method: Q = Norm cross G
        // Caution: Q must be a unit vector, even if G is zero, because it will
        // be the foundation of the PQR coordinate system for diffraction.
        // Get the diffraction quantity also.
        // Start with the local surface normal:

        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        qx = -Norm[RTWL] * gy;
        qy =  Norm[RTWL] * gx;
        qz =  Norm[RTUL] * gy - Norm[RTVL] * gx;

        // normalize these
        qq = U.sqr(qx) + U.sqr(qy) + U.sqr(qz); 
        if (qq > TOL)
        {
            qq = Math.sqrt(qq); 
            qx /= qq; 
            qy /= qq; 
            qz /= qq; 
        }
        else  // g=0, nothing to diffract
        {
            if (bRefl)
              return iMirror(ray, surf);
            else
              return RROK;
        }

        // Get the local groove perpendicular P in vertex coordinates

        px = qy * Norm[RTWL] - qz * Norm[RTVL];   // P = Q x R = groove perp
        py = qz * Norm[RTUL] - qx * Norm[RTWL];
        pz = qx * Norm[RTVL] - qy * Norm[RTUL];

        // Get the incident ray direction in local groove coordinates:

        sp = px*ray[RTUL] + py*ray[RTVL] + pz*ray[RTWL];  // incident dot grooveperp
        sq = qx*ray[RTUL] + qy*ray[RTVL] + qz*ray[RTWL];  // incident dot groove
        sr = Norm[RTUL]*ray[RTUL] + Norm[RTVL]*ray[RTVL] + Norm[RTWL]*ray[RTWL];  // inc dot normal
        double posdot = (sr >= 0.0) ? 1.0 : -1.0; 

        // Diffract the ray in local grating coordinates

        diffract = order * wavel * qq;
        sp = sp + diffract;
        sr2 = 1.0 - U.sqr(sp) - U.sqr(sq); 
        if (sr2 < 0.0)
          return RRORD;

        sr = dAction * posdot * Math.sqrt(sr2); 

        // Put the ray back into vertex coordinates
        ray[RTUL] = sp*px + sq*qx + sr*Norm[RTUL];
        ray[RTVL] = sp*py + sq*qy + sr*Norm[RTVL];
        ray[RTWL] = sp*pz + sq*qz + sr*Norm[RTWL];

        if (!isNormalizedVx(ray))
          U.beep();  // nonnormalized output. 

        return RROK;
    }





    /*-------------vGetPerp finds the perp for any surface------------*/
    /*---------------it always calls Z.vGetZnorm()--------------------*/

    static private void vGetPerp(double ray[], double surf[], double p[])
    // ray[13]; surf[121]; perp[13] is in local frame RTUL, RTVL, RTWL. 
    // This converts ray from 13-dim space in RT13 to 3-Dim space of Z.
    // Then, converts perp "q" from 3-Dim to 13-dim space for RT13. 
    {
        double q[] = new double[3]; 
        Z.vGetZnorm(ray[RTXL], ray[RTYL], surf, q); 
        p[RTUL] = q[0];
        p[RTVL] = q[1];
        p[RTWL] = q[2];  // USUALLY NEGATIVE.  WHY? 
        double soserr = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] - 1.0; 
    }



    /*-----------------some math utilities--------------------*/
    /*-----------------some math utilities--------------------*/
    /*-----------------some math utilities--------------------*/



    static private void labtovx(double rprev[], double rthis[], double surf[])
    // Coordinate frame changer, also moves from surf=j to j+1.
    // Matrix OE converts local to lab coordinates; must transpose it here.
    // Also carries RPATH forward from rprev[] to rthis[]. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003
    {
        double a, b, c;
        a = rprev[RX] - surf[OX];
        b = rprev[RY] - surf[OY];
        c = rprev[RZ] - surf[OZ];
        rthis[RTXL] = surf[OE11]*a + surf[OE21]*b + surf[OE31]*c;
        rthis[RTYL] = surf[OE12]*a + surf[OE22]*b + surf[OE32]*c;
        rthis[RTZL] = surf[OE13]*a + surf[OE23]*b + surf[OE33]*c;
        a = rprev[RU];
        b = rprev[RV];
        c = rprev[RW];
        rthis[RTUL] = surf[OE11]*a + surf[OE21]*b + surf[OE31]*c;
        rthis[RTVL] = surf[OE12]*a + surf[OE22]*b + surf[OE32]*c;
        rthis[RTWL] = surf[OE13]*a + surf[OE23]*b + surf[OE33]*c;
        rthis[RPATH] = rprev[RPATH]; 
    }

    static private void vxtolab(double ray[], double surf[])
    // Coordinate frame changer, single surface.
    // Here the OE matrix is used directly, local to lab conversion. 
    // Converts a vertex-frame ray descriptor to lab frame.
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003
    {
        double a = ray[RTUL];
        double b = ray[RTVL];
        double c = ray[RTWL];
        ray[RU] = surf[OE11]*a + surf[OE12]*b + surf[OE13]*c;
        ray[RV] = surf[OE21]*a + surf[OE22]*b + surf[OE23]*c;
        ray[RW] = surf[OE31]*a + surf[OE32]*b + surf[OE33]*c;
        a = ray[RTXL];
        b = ray[RTYL];
        c = ray[RTZL];
        ray[RX] = surf[OE11]*a + surf[OE12]*b + surf[OE13]*c;
        ray[RY] = surf[OE21]*a + surf[OE22]*b + surf[OE23]*c;
        ray[RZ] = surf[OE31]*a + surf[OE32]*b + surf[OE33]*c;
        ray[RX] += surf[OX];
        ray[RY] += surf[OY];
        ray[RZ] += surf[OZ];
    }


    static private void normalizeLab(double ray[])
    // Normalizes ray components RU RV RW in lab frame
    // Does not repair minus zeros. 
    {
        double r2 = ray[RU]*ray[RU] + ray[RV]*ray[RV] + ray[RW]*ray[RW]; 
        if (r2 > 0)
        {
            double r = Math.sqrt(r2); 
            ray[RU] /= r; 
            ray[RV] /= r; 
            ray[RW] /= r; 
            return; 
        }
        ray[RU] = 0.0; 
        ray[RV] = 0.0; 
        ray[RW] = 1.0; 
    }

    static private void normalizeVx(double ray[])
    // affects all components RTUL RTVL RTWL in vertex frame
    {
        double r2 = ray[RTUL]*ray[RTUL] + ray[RTVL]*ray[RTVL] + ray[RTWL]*ray[RTWL]; 
        if (r2 > 0)
        {
            double r = Math.sqrt(r2); 
            ray[RTUL] /= r; 
            ray[RTVL] /= r; 
            ray[RTWL] /= r; 
            return; 
        }
        ray[RTUL] = 0.0; 
        ray[RTVL] = 0.0; 
        ray[RTWL] = 1.0; 
    }


    static private boolean isNormalizedVx(double[] ray)
    {
        double r2 = ray[RTUL]*ray[RTUL] + ray[RTVL]*ray[RTVL] + ray[RTWL]*ray[RTWL]; 
        double err = r2 - 1.0; 
        return Math.abs(err) < TOL; 
    }


    static private boolean isNormalizedLab(double[] ray)
    {
        double err = U.sqr(ray[RU]) + U.sqr(ray[RV]) + U.sqr(ray[RW]) - 1.0;
        return Math.abs(err) < TOL; 
    }


    static int iGetRoots(double abc[], double xx[])
    // finds all roots including phantom hyperboloid & ellipse farside
    {
        double a = abc[0]; 
        double b = abc[1]; 
        double c = abc[2]; 
        xx[0] = xx[1] = -0.0; 

        if (a == 0.0)
        {
            if (b == 0.0)
              return 0; 
            xx[0] = xx[1] = -c/b; 
            return 1; 
        }
        if (c == 0.0)
        {
            xx[0] = 0.0; 
            xx[1] = -b/a; 
            return 2;
        }
        if (b == 0.0)
        {
            if (c/a > 0.0)
              return 0;
            xx[0]= Math.sqrt(-c/a); 
            xx[1] = -xx[0];  
            return 2;
        }

        //-------abc all nonzero-----

        double discrim = b*b-4.0*a*c; 
        if (discrim < 0.0)
          return 0; 
        if (discrim == 0.0)
        {
            xx[0] = xx[1] = -b/(2*a); 
            return 2; 
        }
        double root = Math.sqrt(discrim); 
        double q = (b>0.0) ? (b+root)/2 : (b-root)/2; 
        xx[0] = -c/q; 
        xx[1] = -q/a; 
        return 2;       
    }


    static int iGetPosRoots(double abc[], double xx[])
    // Returns only positive roots from iGetRoots().
    // Does not prohibit phantom or farside roots.
    // Called by  dQuadSolve(). 
    // REPLACING "TOL" WITH 0.0 as an experiment
    {
        double tol = 0.0; // TOL from B4Constants.java
        int nroots = iGetRoots(abc, xx); 

        int result=0;        
        switch(nroots)
        {
           case 0:  result= -1; break;        // RPMIS 
           case 1:  if (xx[0]>tol) 
                      { result= 1; break;}      // one possible root
                    else
                      {result=0; break; }      // RPBAK 
           case 2:  if (xx[0]>xx[1]) 
                      swap(xx);  
                    if (xx[1]<tol)
                      {result=0; break;}      // RPBAK
                    if (xx[0]>tol)
                      {result= 2; break;}      // two possible roots
                    xx[0] = xx[1];   
                      {result= 1; break;}        // one possible root 
           default: result=0; break;          // SNH
        }

        return result; 
    }


    static void swap(double xx[])
    {
       double t = xx[0]; 
       xx[0] = xx[1]; 
       xx[1] = t; 
    }

} //------------------end of RT13--------------------------------





/** private class MinFit
  * Fits linear function a+bx+cy to collected data xyf[][]
  * @author M.Lampton (c) STELLAR SOFTWARE 2008 all rights reserved.
  */
class MinFit
{
    static double getABC(int n, double data[][], 
    int jx, int jy, int jf, double abc[])
    // Fits {a,b,c} to f(x,y); model = a + b*x + c*y
    // data[][]: first index specifies the data point 0<=i<n; 
    // second index specifies data column: jx or jy or jf.
    // Bias-free even for <data> that is nonzero. 
    // Returns denominator determinant: zero = no fit possible.
    {
        double sums[] = new double[9]; 
        getSums(n, data, jx, jy, jf, sums); 
        
        //----now build the four 3x3 1-D matrices---

        double mat[][] = new double[4][9]; 
        for (int i=0; i<4; i++)
          for (int j=0; j<9; j++)
            mat[i][j] = getElement(i, j, sums); 

        //----finally do the four determinants & ratios----

        for (int i=0; i<3; i++)
          abc[i] = 0.0; 
        double denom = get3x3Det(mat[0]);
        if (denom != 0.0)
          for (int i=0; i<3; i++)
            abc[i] = get3x3Det(mat[i+1])/denom; 
        return denom;
    }

    static void getSums(int n, double xyf[][], 
    int jx, int jy, int jf, double s[])
    {
        for (int j=0; j<9; j++)
          s[j] = 0.0; 
        for (int i=0; i<n; i++)
        {
            s[0] += 1; 
            s[1] += xyf[i][jx]; 
            s[2] += xyf[i][jy]; 
            s[3] += xyf[i][jx]*xyf[i][jx];
            s[4] += xyf[i][jy]*xyf[i][jy]; 
            s[5] += xyf[i][jx]*xyf[i][jy]; 
            s[6] += xyf[i][jf]; 
            s[7] += xyf[i][jx]*xyf[i][jf]; 
            s[8] += xyf[i][jy]*xyf[i][jf]; 
        }
    }

    static double getElement(int m, int i, double sum[])
    // Copy the appropriate sum into one matrix element. 
    // Index m specifies which kind of matrix: 
    // m=0 is denom; m=1 is anum; 2=bnum; 3=cnum.
    // Index i=0...8 is matrix element sought.
    {
        switch (i)
        {
           case 0: return (m==1) ? sum[6] : sum[0];
           case 1: return (m==2) ? sum[6] : sum[1];
           case 2: return (m==3) ? sum[6] : sum[2]; 
           case 3: return (m==1) ? sum[7] : sum[1];
           case 4: return (m==2) ? sum[7] : sum[3];
           case 5: return (m==3) ? sum[7] : sum[5];
           case 6: return (m==1) ? sum[8] : sum[2];
           case 7: return (m==2) ? sum[8] : sum[5]; 
           case 8: return (m==3) ? sum[8] : sum[4];
           default: return 0.0;
        }
    }

    static double get3x3Det(double a[])
    // Determinant of a 3x3 real matrix written as a 9-element vector. 
    {
       return a[0]*(a[4]*a[8] - a[5]*a[7])
             -a[1]*(a[3]*a[8] - a[5]*a[6])
             +a[2]*(a[3]*a[7] - a[4]*a[6]); 
    }
}
