package com.stellarsoftware.beam;

import java.text.DecimalFormat; // for debugging only

/** This file contains public class RT13 and private class MinFit
  *  A207: eliminating groups, using 5x4 ray/surf logic.
  *  A207.11 implementing TASK DIAGRAM in DevelopmentNotes.txt
  *  ..including distinguishing getHowfarOK vs getHowfarLoop(), getFailSurf and getFailCode.
  *  
  *  A206 Converting mirrors to bimodal: never kill rays but update rayseq[][].
  *  Rod Andrew finds one crazy ray  "StrayRay.OPT" being explored here. 
  *  It is at line 419 that mirrors escape failure.  NOPE somewhere else.
  *
  *  A205 Implementing intercept failure surface "iFailSurf" and "iFailCode"
  *  A201 Yikes needs an error message * sxplanation for line 206...
  *       if (Double.isNaN(wavel))
  *           return RRUNK;
  *  that explains need NUMERICAL wavelengths not letter codes. 
  *  A200: improved smartUVW() fixup not yet installed. 
  *  A198: meat-ax fixup for RU, RV, RW installed; line 1065
  *  A195, A196: uniform top hat scatter added for Rod Andrew.
  *  A192, A193, A194: curl free VLS installed for Hettrick.
  *  A188, 189: adopted class Triple for refraction, diffraction
  *  A186 Sep 2015: eliminated final refraction into vacuum in getRefraction()
  *  A169 March 2015: Added RTANGLE each intercept ray dot normal, in iRedirect.
  *
  * Schematic ray loop, without bailouts:
  *
  *    for (j=1; j<=nsurfs; j++)
  *    {
  *        labtovx(ray[j-1], ray[j], surf[j]); // translate then rotate to localframe
  *        d = dIntercept(ray[j], surf[j]);    // evaluate distance to intercept
  *        vPropagate(ray[j], d, surf[j]);     // advance ray to surface
  *        iRedirect(ray[j], surf[j]);         // redirect ray in local frame
  *        vxtolab(ray[j], surf[j]);           // rotate then translate to labframe
  *    }
  *
  *
  *    PHANTOM HYPERBOLOIDS DO NOT EXIST  "mis"
  *    FARSIDE ELLIPSOIDS DO NOT EXIST    "mis"
  *
  * A166 Jan 2015: reworked redirectors CBin, CBout: now copies local to local.
  * A154: installed Bimodal lens, new logic; TIR failures...
  * A148: removed Bimodal lenses.
  * A147: installing Bimodal lens that can bypass a Dia or dia fault.
  *  new optics surface types: OTBLFRONT, OTBLBACK;
  *  new ray failure codes:  RRBII, RRBIO
  *  Diams decision is moved into iRedirect to handle these situations. 
  *  iIntercept(): line 982;  iDiams(): line 915; iRedirect(): line 1555.
  *  
  * A143: Reinstalling groups. Issues:
  *  LayoutPanel and MapPanel both call dGetSurf(): illegal with groups.
  *
  * A139: Eulers now correspond to the Users Guide: convert from local to lab.
  *   Impact: RT13 labtovx(), vxtolab(), setEulers(), LayoutPanel.
  *
  * To run the rays, call public method iBuildRays(bAll, nrays, nsurfs).
  *   Here, use nsurfs, not ngroups.  Collapsing to groups happens later. 
  *   Runs all table rays,
  *   Makes output available as dRays[][][].
  *   Computes all ganged goals
  *   Computes WFE, using MinFit for pupil piston & slopes
  *
  * rev 137, simplified, with NO GROUPS; see bRunOneRay(), line 288
  *
  * rev 134, Feb 2012: installed iGetPosRoots() to simplify dQuadsolve(). 
  *   this new routine means that BAK roots can be promptly dismissed
  *   thereby simplifying the gnarly root selection logic: hyperboloid sheet,
  *   oblate & prolate cases are sweetly distinguished; parabolas always OK.
  *   Two good roots: dQuadSolve() now calls new testDiameter().
  *   New default for two good roots: return shorter path i.e. "first" intercept.
  *   The "<" type tag is redefined as root closer to the vertex.
  *   The ">" type tag continues to serve longer ray path intercept. 
  * 
  *   A complete ellipsoid can be made by grouping two hemiellipsoids;
  *   see new example 9-17 p.53 Ellipsoid.OPT and Ellipsoid.RAY.
  *
  * rev 133: Feb 2012: dQuadSolve was permitting farside intercepts.
  *   Yikes. Bizarre layouts!  Steve Tulk's questions about this. 
  *   See line 1085 and the booleans OK0 and OK1.
  *
  * rev 128: added iScatter(), a Gaussian forward scatter surface. 
  *   but no iBragg() since 2d.sin(theta)/Lam is never an integer.
  *
  * rev 123: dQuadSolve has 16 state decision tree. 
  *
  * Default quadratic intercept is posroot nearer vertex.
  * Policy override "<" (shorter) and ">" (longer) is in dQuadSolve(). 
  *
  * Random rays (k==0) are generated by iInitRaySeq(), line 700 below.
  *
  * To enforce use of iBuildRays() and reject client loops through bRunray(),
  * bRunray(kray) is now private.  But to allow its use for individual
  * random rays, a new public method bRunRandomRay() handles WFE and
  * calls private bRunray(0)
  *
  * rev 112: Groups are introduced.  Public arrays are set by OEJIF:
  *    RT13.jstart[g]
  *    RT13.jstop[g]
  *    RT13.group[j]
  * but beware j[group] is not stored, it is ray dependent.
  *
  * rev 104: Reworking the near/far intercept permissions for conics.
  *  Problem has been farside intercepts = valid when ought to fail. 
  *  Failure code "bak" seems to be unavailable, but is needed in this case.
  *
  * rev 118: includes biconic surface profile.  See Z.java
  *
  * rev A62: WFE correction method (line 377) is available to all rays.
  *
  * rev A34: nstalled analytic differentiator for all surfaces;
  * this will need exhaustive testing, including "farside" intercepts. 
  *
  * Relies upon Z.vGetZsurf() for the surface model beyond conics & cylinders: numerical solvers.
  * Relies upon Z.vGetNormal() for surface gradients and conversion to normal vector. 
  *
  * Local int  "howfarLoop" is how far the loop went, ray=OK or not.
  * Local int "howfarOK" is how far there was an RROK.
  * Reason:  In "Message NN" the NN = howfarLoop, and message is OK or fail.
  * And: in Layout, Plot2D, Plot3 need howfarOK to validate each ray point {xyz}.
  * 
  * Method initRaySeq() is private, no client interfaces;
  * Calling initRaySeq() within bRunray() case (krand==1) setup. 
  *
  * public output methods: getStatus(), getHowfarOK(), getHowfarLoop(), getExtend().
  *
  *
  * setTableDirection()    handles RayTable & DefaultRay choices
  * setRandomDirection()   called here in bRunray(): uses smins, spans
  *
  *-------------------Dramatis Personae of runray()----------------------
  *    iIntercept() uses analytic or Brent  << does not modify ray[].
  *    vPropagate() is self sufficient      << modifies xyz of ray[].
  *    iDiams() is self sufficient          << does not modify ray[].
  *    iRedirect() calls vGetPerp()         << modifies uvw of ray[]. 
  *    Note: vGetPerp() converts to 3-dim, calls Z.vGetPerp()
  *          and then converts 3-dim back to 13-dimensions. 
  *
  * Solvers provide recommended ray distances "d" but do not propagate.
  * Reason: there is sanity testing for each recommended solution. 
  * Especially so with Groups!
  *
  * Main loop bRunray() must explicitly propagate, then call iDiams() for logic.
  * 
  *
  *----public input arrays----------- 
  *      surfs[][]          << filled by OEJIF; modified by Map,MPlot..
  *      raystarts[][]      << filled by REJIF; modified by AutoRay
  *      iWFEgroup[]        << filled by REJIF
  *      spans[]            << filled by REJIF
  *      smins[]            << filled by REJIF
  *      smaxs[]            << filled by REJIF
  *      media[][]          << filled by MEJIF
  *
  *----output array-------------- 
  *      dRays[][][]        << now private! replaced by a public accessor.
  *      dGetRay(kray, jsurf, iattrib) to include WFE, whose internal 
  *      organization is very different from dRays[].
  *
  * Uses no classes other than Consts; LUTs are based *here*. 
  * Based on 13-element rays: lab6 + local6 + path. 
  *
  *
  *   Client REJIF must set up raystarts[][], smins[], spans[];
  *      --raystarts[] should NOT include defaults, nor fixups.
  *      --all missing data flagged by REJIF as -0.0
  *   Client then must run iBuildRays()
  *
  *   Client can ask for any resulting datum for any ray:
  *       int getHowfarOK(), int getStatus(), double dGetRay(k, j, attrib).
  *   runseq[][] is dwells within this class.
  *
  * Internally, VxtoLab etc all act on a 13-element ray not 6-element ray.
  *
  *
  *
  *
  * @author M.Lampton (c) STELLAR SOFTWARE 2004 all rights reserved.
  */
class RT13 implements B4constants
{
    private static int iFailSurf, iFailCode; // for AutoAdjust line 298
    
    /*--------public input working arrays for OEJIF and REJIF------*/
    /*-------RNSTARTS = 10, the number of ray start attributes-----*/

    public static double  surfs[][]      = new double[MAXSURFS+1][ONPARMS]; 
    public static double  raystarts[][]  = new double[MAXRAYS+1][RNSTARTS]; 
    public static double  spans[]        = new double[RNSTARTS];  // set by REJIF
    public static double  smins[]        = new double[RNSTARTS];  // set by REJIF
    public static double  smaxs[]        = new double[RNSTARTS];  // set by REJIF
    public static double  media[][]      = new double[MAXMEDIA+1][MAXFIELDS]; 

    public static int     gO2M[] = new int[MAXSURFS+1]; // from DMF; for jsurf gives glass ID
    public static int     gR2W[] = new int[MAXRAYS+1];  // from DMF; for kray gives wavel ID

    //----gwave allows MPlotPanel to commandeer wavelengths; see getRefraction()---
    //------for all other purposes keep gwave=0 so rays control wavelengths--------

    public static int     gwave = 0;   
 
    /*----------------public output arrays-------------------*/


    public static double  refractLayoutShading[] = new double[MAXSURFS+1]; 
    public static boolean isRayOK[] = new boolean[MAXRAYS+1]; 
    // public static int     iWFEgroup[] = new int[MAXRAYS+1];  // eliminated A207
    // public static double     dot[] = new double[MAXRAYS+1];  // moved into attribs
    

    /*------------------------------------------------------*/
    /*-------------------- public methods-------------------*/
    /*------------------------------------------------------*/
    
    public static int getFailSurf()  // set in line 664; called by AutoAdjust line 297.
    {
        return iFailSurf;
    }
    
    public static int getFailCode()  // set in line 665; called by AutoAdjust line 297.
    {
        return iFailCode;
    }

    static public double dGetRay(int kray, int j, int iattrib)
    // Accesses any one ray trace result, after iBuildRays() has been run.
    // "j" is the desired surface number.
    {
        if (j<0)
            System.out.println("RT13.dGetRay() HAS BEEN ASKED ABOUT NEGATIVE SURFACE = "+j);
        if ((iattrib >= RX) && (iattrib < RTWFE))  // now includes RTDOT
        {
            double x = dRays[kray][j][iattrib];
            return x; 
        }
        // if (iattrib == RTWFE)
        //   return dWFE[kray]; //--why use a special array for WFE?
        return -0.0; 
    }

    static public double dGetRayFinal(int kray, int iatt)
    // called by MapPanel after iBuildRays() has been run.
    {
        int jsurf = DMF.giFlags[ONSURFS]; 
        return dRays[kray][jsurf][iatt]; 
    }
    
    
    static public double dGetSurfParm(int iatt, int jsurf)
    // Returns one of the many surface parameters & attributes. 
    // Needed for Map function when surface is to be deviated for mapping.
    // Called by MapPanel and LayoutPanel. 
    {
         if ((iatt < 0) || (iatt > ONPARMS))  // allows OTYPE etc
           return -0.0; 
         if ((jsurf < 1) || (jsurf > MAXSURFS))
           return -0.0; 
         return surfs[jsurf][iatt]; 
    }

    static public int getSurfNum(int opcode)
    // Converts a given opcode into its surface number.
    // This handles the case of "final" by returning nsurfs. 
    // Callers should always test this result for error situation = -1!
    { 
        int nsurfs = DMF.giFlags[ONSURFS]; 
        if (opcode < 0)
          return -1; 
        int attr = opcode % 100;
        if (attr > 20)  // eliminate RNOTE, RBUG...
          return -1; 
        int surf = opcode/100; 
        if (surf == RFINAL/100)  // handles "final"  
          return nsurfs; 
        if (surf > nsurfs)
          return -1; 
        return surf; 
    }
    
    
    static public int getAttrNum(int opcode)
    // Always test result for situation = -1!
    {
        opcode %= 100; 
        if (opcode >= RNATTRIBS) // eliminate RNOTE, RBUG...
          return -1;
        else
          return opcode; 
    }


    static public int getStatus(int kray)
    // Returns RROK or ray error code for "kray"
    // Decode these with B4constants sResults[] array. 
    {
        return status[kray]; 
    }


    static public int getHowfarLoop(int kray)
    // Returns how far the *loop* went, 1...ngroups
    // even though the ray may have failed or terminated OK.
    // Use this in InOut's explanations. 
    {
        return howfarLoop[kray]; 
    } 


    static public int getHowfarOK(int kray)
    // Returns how far the *ray* went, 0....nsurfs
    // Used by Layout for jsolid, and Plot2D Plot3D for item validation
    {
        return howfarOK[kray]; 
    } 
   


    static public boolean getExtend(int kray)
    // Returns true if the ray should be drawn with a dotted extension
    // True for bak, mis, Diam, diam, but not Iris, iris, spider.
    // Called by layout; loaded within local bRunray().
    {
        return bExtend[kray];
    }


    static public int getGuideRay()
    // Returns the number 1...nrays of ray whose color, wavel, order is in use.
    // Most useful for random rays, where kray=0. 
    // Yikes in A207 this is always zero!  Must never be zero!
    // Modifying it to return a random integer 1...Nrays
    // MUST NEVER RETURN ZERO.
    {
        return kGuideRay;
    }


    static public double getRefraction(int jsurf, int gkray)
    // if gwave==0: Returns index approaching jsurf, using gkray @wave.
    // if gwave>0: returns index approaching jsurf, using media @gwave.
    // Mostly called by public iBuildRays()
    // Called by LayoutPanel for shading with gkray=1. 
    // Called by redirectors, below, for Snell's law and optical path.
    // gO2M[] is evaluated in DMF when parsing is complete
    // gR2M[] is evaluated in DMF when parsing is complete
    {
        // First: try to get refr from surfs[][] set by OEJIF.
        // If OK, use it; else use media LUT. 
        // System.out.println("-------RT13.getRefraction is starting with jsurf, gkray = "+jsurf+"  "+gkray);
        int nsurfs = DMF.giFlags[ONSURFS]; 
        if (jsurf<1)
          return 1.0;        // error condition
        if (jsurf > nsurfs)
          jsurf = nsurfs;   // eliminate final refraction to vacuum; A186
        double refr = surfs[jsurf][OREFRACT]; 
        if (Double.isNaN(refr))
        {
            // System.out.println("RT13.getRefraction finds NAN at jsurf, kray = "+jsurf+"  "+gkray); 
            int k = gkray; 
            if (gkray==0)
            {
                k = getGuideRay();
                // System.out.println("RT13.getRefraction is trying GuideRay = "+k);
            }
            
            // int k = (gkray==0) ? getGuideRay() : gkray; 
            if (k<1)
            {
                // System.out.println("RT13.getRefraction has a null ray; error, exitting.");
                return 1.0;    // error condition; 
            }
            int iglass = gO2M[jsurf]; 
            // System.out.println("RT13.getRefraction finds iglass = "+iglass); 
            if (iglass<1)
              return 1.0;    // error condition
            int iwave = gR2W[k]; 
            // System.out.println("RT13.getRefraction finds iwave = "+iwave); 
            if (gwave>0)     // global mandate to use given iwave: MPlotPanel
            {
                // System.out.println("RT13.getRefraction finds positive gwave = "+gwave); 
                iwave = gwave; 
            }
            if (iwave<1)
            {
                // System.out.println("RT13.getRefraction finds iwave < 1: error, exitting."); 
                return 1.0;    // error condition
            }
            double n = media[iglass][iwave]; // media[][] was filled in by MEJIF line 100
            // System.out.printf("RT13.getRefraction using media[][], gets n = %8.4f\n", n); 
            return n; 
        }
        // System.out.printf("RT13.getRefraction using surfs: n = %8.4f \n", refr);
        if (refr == 0.0)
        {   
            // System.out.println("RT13.getRefraction finds zero! returning 1.0 and exitting."); 
            refr = 1.0; 
        }
        return refr;
    }


    static public void setEulers()
    // fixes up all missing fields in optical surface definition
    // Generate matrix converting local to lab frame. 
    // Use transpose to convert lab frame to local. 
    // Sequence is tilt(x), pitch(y'), roll(z").
    // Called by Auto.dNudge(), OEJIF.parse(), MPlot. 
    // Used by RT13:: labtovx() and vxtolab()().
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // Enlarged to include six Hettrick implicit groove parameters, A192 March 2016
    {
       double ct, st, cp, sp, cr, sr; 
       for (int j=1; j<=DMF.giFlags[ONSURFS]; j++)
       {
           ct = U.cosd(surfs[j][OTILT]); 
           st = U.sind(surfs[j][OTILT]); 
           cp = U.cosd(surfs[j][OPITCH]); 
           sp = U.sind(surfs[j][OPITCH]); 
           cr = U.cosd(surfs[j][OROLL]); 
           sr = U.sind(surfs[j][OROLL]);            
           surfs[j][OE11] = cr*cp;               // X <- x; M11
           surfs[j][OE12] = -sr*cp;              // X <- y; M12
           surfs[j][OE13] = sp;                  // X <- z; M13
           surfs[j][OE21] = cr*sp*st + sr*ct;    // Y <- x; M21
           surfs[j][OE22] = cr*ct - sr*sp*st;    // Y <- y; M22
           surfs[j][OE23] = -cp*st;              // Y <- z; M23
           surfs[j][OE31] = -cr*sp*ct + sr*st;   // Z <- x; M31
           surfs[j][OE32] = sr*sp*ct + cr*st;    // Z <- y; M32
           surfs[j][OE33] = cp*ct;               // Z <- z; M33
       }
       
       //---Hettrick implicit polynomial coefficients  A192; A193---------
       for (int j=1; j<DMF.giFlags[ONSURFS]; j++)
       {
           // surfs[j][OVX01] = surfs[j][OVY10]; 
           // surfs[j][OVX02] = surfs[j][OVY11]/2.0;
           // surfs[j][OVX03] = surfs[j][OVY12]/3.0; 
           // surfs[j][OVX11] = surfs[j][OVY20]*2.0; 
           // surfs[j][OVX12] = surfs[j][OVY21]; 
           // surfs[j][OVX21] = surfs[j][OVY30]*3.0; 
           
           surfs[j][OVX01] = surfs[j][OVY10]; 
           surfs[j][OVX02] = surfs[j][OVY11]/2.0;
           surfs[j][OVX03] = surfs[j][OVY12]/3.0; 
           surfs[j][OVX04] = surfs[j][OVY13]/4.0;
           surfs[j][OVX11] = surfs[j][OVY20]*2.0; 
           surfs[j][OVX12] = surfs[j][OVY21]; 
           surfs[j][OVX13] = surfs[j][OVY22]*2.0/3.0;
           surfs[j][OVX21] = surfs[j][OVY30]*3.0; 
           surfs[j][OVX22] = surfs[j][OVY31]*3.0/2.0;
           surfs[j][OVX31] = surfs[j][OVY40]*4.0;
        }
    }


  
    static public int iBuildRays(boolean bAll)
    // This runs all table rays or just the previously good table rays. 
    // NOTA BENE this is nsurfs not ngroups!  Because it uses bRunOneRay.
    // Builds dRays[] by calling bRunray() for each ray start.
    //  (bRunray() uses iInitRaySeq() to set up each ray, even random rays.)
    // Builds dWFE[] from aggregate dRays[].
    // If bAll=true, it tries all rays and writes isRayOK[].
    // If bAll=false, it assumes isRayOK[] is correct and runs only known good rays.
    // This is a laborsaver, used in Auto.  Check for freshly failed rays!
    // In either case it returns the number of good rays. 
    //
    // Be sure RT13.gwave=0 except for MPlotPanel external wavelength command. 
    // RT13.gwave is a key control parm for RT13.getRafraction(). 
    //
    // M.Lampton STELLAR SOFTWARE (C) 2007
    {
        int gnrays = DMF.giFlags[RNRAYS]; 
        int gnsurfs = DMF.giFlags[ONSURFS]; 
        // System.out.println("Starting RT13.iBuildRays()");

        for (int k=0; k<=gnrays; k++)
           for (int j=1; j<gnsurfs; j++)
            for (int iatt=0; iatt<RNATTRIBS; iatt++)
              dRays[k][j][iatt] = -0.0; 

        ngood = 0; 
        iFailSurf = 0;
        iFailCode = 0; 
        for (int k=1; k<=gnrays; k++)
        {
            kGuideRay = k; // ABSOLUTELY CRUCIAL TO USE THIS FOR REFRACTIONS
            if (bAll || isRayOK[k])
            {
                boolean bOK = bRunOneRay(k);
                if (bOK)
                  ngood++; 
                if (bAll)
                  isRayOK[k] = bOK;
            }
        }
        // doWFEtask(ngood, gnrays, gnsurfs); // temporary elimination
        return ngood; 
    } //---end of iBuildRays()------


   
    

    static public boolean bRunOneRay(int k) 
    // Runs a single ray. If k==0, random ray; else table ray.
    // Returns TRUE if raystatus == RROK, else FALSE.
    // M.Lampton STELLAR SOFTWARE (c) 2012, 2018 
    // Working directly in dRays[kray][j][iatt] not rayseq[j][iatt]
    // Ray action pattern is from RT158.py; every good intercept propagates.
    // Must undo this propagation for bimodal failures for DIA,dia,SPI,ORD,TIR...
    // To undo, don't reverse with distance "d" but instead copy previous {XYZ}
    //
    // A207: Random rays are created in four steps by iCreateOneRandomRayStart():
    //    1. A randomly chosen "guide ray" all attributes are copied into raystarts[0]
    //    2. {XYZUVW} get randomized from raystart spans, not wavel nor path
    //    3. {UVW} get fixed up.
    //    4. The guide ray's index is set here, used by getRefraction()
    // Q: shouldn't each attrib be separately chosen, to mix them up better?
    // A: Yes.
    //
    // A207: new policy on bExtend:
    //  * for all intercept failures, set bExtend=true;
    //  * for OK and all other failures, set bExtend=false.
    // This way the final word is set by the final ray segment result. 
    {
        // System.out.println("RT13.bRunOneRay() starting with k = "+k); 
        
        if (k==0)                    // prepare a complete random raystart as kray=0
        {
           kGuideRay = iCreateOneRandomRayStart();  // kGuideRay is for getRefraction(), never zero.
        }
        
        int nsurfs = DMF.giFlags[ONSURFS]; 
        int code = RROK;             // status of this ray, 4 kinds
        int codex = 0;               // status of this ray, 16 kinds
        int prevx = 0;               // previous status, 16 kinds.
        howfarOK[k] = 0;             // progress indicator
        howfarLoop[k] = 0;           // progress indicator
        bExtend[k] = false;          // request for graphic extension; otherwise call vxtolabs()
        boolean kill = false;        // request to kill this ray
        boolean skip = false;        // request to skip this surface

        for (int iattrib=RX; iattrib<=RPATH; iattrib++)    // copy all seven starts into lab surface zero
            dRays[k][0][iattrib] = raystarts[k][iattrib];  // What about wavel? Separate wavel list.
            
        fixupLabUVW(k); 
        int jTopHit = 0;              // no RROK's hits yet
                
        for (int j=1; j<=nsurfs; j++) // j = target surface loop
        {
            if (DEBUG)
               System.out.println("\n============RT13.bRunOneRay() starting k, j = " + k + "  " + j);
            code = RROK; 
            bExtend[k] = false; 
            kill = false; 
            skip = false; 
            labtovx(k, jTopHit, j);    // jTopHit is previous j with RROK
                             
            code = intercept(k,j);     // propagates if RROK; else RRMIS, RRBAK. line 1250
            if (code==RROK)
                code = validate(k,j);  // RROK else RRDIA, RRdia, RRSPI; line 1600
            if (code==RROK)
                code = redirect(k,j);  // RROK else RRORD, RRTIR, RRTER, RRUNK; line 1850
            if (DEBUG)
               System.out.println("RT13.bRunOneRay() finds trace code = "+sResults[code]); 
            
            // Now index the failure code result 
            
            int rrindex = 0;                // default no error    "OK"
            if ((code==RRMIS) || (code==RRBAK) || (code==RRBRA))
                rrindex = 1;                // Intercept Fail      "IF"
            if (code==RRDIA)
                rrindex = 2;                // Pupil Outer diameter fail "PO"
            if ((code==RRdia))
                rrindex = 3;                // Pupil Inside diameter fail "PI"
            if ((code==RRSPI) || (code==RRORD) || (code==RRTIR) || (code==RRUNK))
                rrindex = 4;                // Redirection Fail     "RF"
                
            if (code==RROK)                 // update jTopHit for this ray
               jTopHit = j; 
               
            // Now index the surface codes
            
            int ssindex = 0;                // default unimodal surface
            if (surfs[j][OTYPE]==OTBMIRROR)
                ssindex = 1;                // bimodal mirror  
            if (surfs[j][OTYPE]==OTBLFRONT)
                ssindex = 2;                  // bimodal lens front
            if (surfs[j][OTYPE]==OTBLBACK)
                ssindex = 3;                  // bimodal lens back
            if (surfs[j][OTYPE]==OTTERMINATE)
                ssindex = 4; 
                
            codex = rrindex + CODEXMULT * ssindex; 

            
            if (DEBUG)
            {
                int iType = (int) surfs[j][OTYPE];
                String st = sTypes[iType];
                String sc = sCodex[codex];  
                System.out.println("RT13.bRunOneRay() has k, j, surftype, rr, ss, codex = "+k+"  "+j+"  "+st+"  "+rrindex+"  "+ssindex+"  "+sc); 
            }
            
            // Now implement the logic in DevelopmentNotes.txt; there are 20 cases. 
            // Each alternative has one vxtolab() per surface, but if bExtend is set, that is overwritten. 
            // InterceptFail "IF" cases must not attempt bExtend.
            // Be sure to explicitly handle every case so as to avoid calling the Police.
            
            switch(codex)
            {
                case UNIRF:                                                   // count=1
                case BMRF:                                                    // count=2
                case BLFRF:                                                   // count=3
                case BLBRF: {                                                 // count=4
                             skip = false; 
                             bExtend[k]=false; 
                             vxtolab(k,j);
                             clobberUVW(k,j); 
                             kill = true;  
                             break;}                                          // propagated failed rays
                
                case UNIOK:                                                   // count=5
                case BMOK:                                                    // count=6
                case BLFOK: {howfarOK[k]=j;                                   // count=7
                             skip = false; 
                             bExtend[k]=false;
                             vxtolab(k,j); 
                             kill = false; 
                             break;}                                          // good rays
                
                case UNIIF:                                                   // count=8
                case UNIPO:                                                   // count=9
                case UNIPI: {skip = false;                                    // count=10
                             bExtend[k]=true; 
                             clobberUVW(k,j); 
                             kill=true; 
                             break;}                                          //  failed; cleaned up
                                
                case BMIF:                                                    // count=11
                case BMPO:                                                    // count=12
                case BMPI:                                                    // count=13
                case BTIF:                                                    // count=14
                case BTPO:                                                    // count=15
                case BTPI:                                                    // count=16
                case BTRF:                                                    // count=17
                       {skip = true; bExtend[k]=true; break;}                 // skip to next 
                
                case BLFIF:                                                   // count=18
                case BLFPO:                                                   // count=19
                case BLFPI: {skip = true; bExtend[k]=true; break;}            // count=20; wait and see  
                
                case BLBOK: if (prevx==BLFOK)                                 // count=21
                               {howfarOK[k]=j; vxtolab(k,j); break;}          // good ray
                            else
                               {vxtolab(k,j);                                 // bad ray
                                kill=true; 
                                codex=BLBXO;
                                code=RRBXO;
                                bExtend[k]=true; 
                                break;}        
                               
                case BLBIF:                                                   // count=122
                case BLBPO:                                                   // count=23
                            if ((prevx==BLFIF) || (prevx==BLFPO))             // bypass OD OK
                               {skip=true; bExtend[k]=true; break;}
                             else
                                {skip=false;                                  // failed bypass OD.
                                 kill=true; 
                                 codex=BLBXO;
                                 code=RRBXO; 
                                 bExtend[k]=true; 
                                 break; }
                               
                case BLBPI:                                                   // count=24 
                           if (prevx==BLFPI)
                              {skip=true; bExtend[k]=true; break;}            // bypass ID OK
                           else
                              {skip=false;                                    // failed bypass ID. 
                              kill=true; 
                              codex=BLBXO;
                              code=RRBXO; 
                              bExtend[k] = true; 
                              break;}                         
                              
                case BTOK:                                                   // count=25: kill
                           {howfarOK[k]=j; 
                            vxtolab(k,j); 
                            skip=false; 
                            bExtend[k]=false; 
                            kill=true; 
                            break;}
                                 
                default:    System.out.println("RT13.switch() fail: k, j, prevx, codex = "+k+"  "+j+"  "+sCodex[prevx]+"  "+sCodex[codex]);
            }

            prevx = codex;          
            howfarLoop[k] = j;        
            if (kill)
            {
                iFailSurf = j;
                iFailCode = codex; 
                break; 
            }
            if (skip)
                clobberAll(k,j); 
        }
        if (bExtend[k])
            vExtendLabs(k); // this overwrites the final vxtolab()
        if (DEBUG)    
           System.out.println("bRunOneRay() is exitting loop with code, codex = "+sResults[code]+"  "+sCodex[codex]+"\n");
        boolean bFullDistance = (howfarOK[k] == nsurfs);
        status[k] = code;          // update the status flag 
        return bFullDistance;      // (code==RROK)? final bypasses are not OK since howfar<Nsurfs. 

    } //--------end of bRunOneRay()-----------------------



    static public boolean bRunRandomRay()
    // This edition has no WFE group support. A207
    {
        return bRunOneRay(0);   // includes iCreateOneRandomRayStart()
    }





    /*-----------------------------------------------------------*/
    /*-------------------------private zone----------------------*/
    /*-----------------------------------------------------------*/

    private static int kGuideRay      = 0; 
    private static boolean bExtend[]  = new boolean[MAXRAYS+1]; 
    private static int status[]       = new int[MAXRAYS+1];
    private static int howfarOK[]     = new int[MAXRAYS+1];
    private static int howfarLoop[]   = new int[MAXRAYS+1]; 
    
    private static double dRays[][][] = new double[MAXRAYS+1][MAXSURFS+1][RNATTRIBS];

    private static boolean   bUserOptionPositive = true; 
    private static int       iUserOptionMethod = 0; 
    private static double    dIsoRadius = 0.0; 
    
    /*--------------for WFE table and random-----------------*/

    // private static double dWFE[]      = new double[MAXRAYS+1];      
    // private static double sWFE[][]    = new double[MAXWFEGROUPS][3]; 
    // private static double eWFE[][]    = new double[MAXWFEGROUPS][3]; 
    // private static double avgWFE[]    = new double[MAXWFEGROUPS]; 
    // private static double tiltWFE[][] = new double[MAXWFEGROUPS][3]; 
    // private static int    ijWFE[][]   = new int[MAXWFEGROUPS][2];     // pupil
    
    private static int ngood = 0; 
    
    
/* A207 eliminated this task temporarily

    static private void doWFEtask(int gngood, int gnrays, int gnsurfs)
    // Run this after each ray trace regardless of presence of WFEcolumn.
    // It computes dWFE[] using dRays[][][] data. 
    // It saves ray start sWFE[][] and ray end eWFE[][] information,
    // then evaluates the table ray WFEs, saved into dWFE[].
    // Don't bother saving into dRays[6]; save into dWFE[] only. 
    // Subsequent random rays can use sWFE & eWFE for their WFEs,
    // provided that they are organized to use kGuideRay. 
    //
    // How to apply MinFit? For each WFEgroup,
    // identify & save the pupil coord pair ijWFE[][];
    // compute & save tilts as tiltWFE[][] from MinFit. 
    // Make these available to bRunRandomRay() --line 177--- as well. 
    {
        for (int k=1; k<=gnrays; k++)
          dWFE[k] = -0.0; 

        if (gngood < 1)
          return; 

        int ngroups = DMF.giFlags[RNWFEGROUPS];

        for (int ig=0; ig<ngroups; ig++)           //---zero start & end----
        {
            for (int iatt=RX; iatt<=RZ; iatt++)
               sWFE[ig][iatt] = eWFE[ig][iatt] = 0.0; 
            ijWFE[ig][0] = 0;        // no group vars yet
            ijWFE[ig][1] = 0; 
            tiltWFE[ig][0] = 0.0;    // no tilt fit yet. 
            tiltWFE[ig][1] = 0.0;
            tiltWFE[ig][2] = 0.0;  
        } 

        for (int ig=0; ig<ngroups; ig++)           //--average start & end----
        {
            int ngg = 0;
            for (int k=1; k<=gnrays; k++)
              if (isRayOK[k] && (ig == iWFEgroup[k]))
              {
                  sWFE[ig][RX] += dRays[k][0][RX]; 
                  sWFE[ig][RY] += dRays[k][0][RY]; 
                  sWFE[ig][RZ] += dRays[k][0][RZ]; 
                  eWFE[ig][RX] += dRays[k][gnsurfs][RX]; 
                  eWFE[ig][RY] += dRays[k][gnsurfs][RY]; 
                  eWFE[ig][RZ] += dRays[k][gnsurfs][RZ]; 
                  ngg++; 
              };
            if (ngg < 1)
            {
               continue; 
            }
            sWFE[ig][RX] /= ngg; 
            sWFE[ig][RY] /= ngg;
            sWFE[ig][RZ] /= ngg; 
            eWFE[ig][RX] /= ngg;
            eWFE[ig][RY] /= ngg;
            eWFE[ig][RZ] /= ngg;
        }

        double dsk, dek; 
        for (int k=1; k<=gnrays; k++)         //---correct each ray-----
          if (isRayOK[k])
          {
              int ig = iWFEgroup[k]; 
              dsk = (dRays[k][0][RX]-sWFE[ig][RX])*dRays[k][0][RU]
                  + (dRays[k][0][RY]-sWFE[ig][RY])*dRays[k][0][RV]
                  + (dRays[k][0][RZ]-sWFE[ig][RZ])*dRays[k][0][RW];

              dek = (dRays[k][gnsurfs][RX]-eWFE[ig][RX])*dRays[k][gnsurfs][RU]
                  + (dRays[k][gnsurfs][RY]-eWFE[ig][RY])*dRays[k][gnsurfs][RV]
                  + (dRays[k][gnsurfs][RZ]-eWFE[ig][RZ])*dRays[k][gnsurfs][RW];

              dWFE[k] = dRays[k][gnsurfs][RPATH] + dsk - dek;
          }

        for (int ig=0; ig<ngroups; ig++)     //---average each group----
        {
            avgWFE[ig] = 0.0; 
            int ngg = 0; 
            for (int k=1; k<=gnrays; k++)
            {
                if (isRayOK[k] && (ig == iWFEgroup[k]))
                {
                    avgWFE[ig] += dWFE[k];
                    ngg++; 
                }
            }
            if (ngg < 1)
            {
               return; 
            }
            avgWFE[ig] /= ngg; 
        }

        for (int k=1; k<=gnrays; k++)   //----subtract group average-----
          if (isRayOK[k])
            dWFE[k] -= avgWFE[iWFEgroup[k]];

        //-----------now fit spherical wavefront to WFE------

        double rr[][] = new double[MAXRAYS][7]; 
        for (int ig=0; ig<ngroups; ig++)
        {
            int ngg = 0; 
            for (int k=1; k<=gnrays; k++)
            {
                if (isRayOK[k] && (ig == iWFEgroup[k]))
                {
                    for (int iatt=0; iatt<6; iatt++)
                      rr[ngg][iatt] = dRays[k][gnsurfs][iatt]; 
                    rr[ngg][6] = dWFE[k]; // capture input from above
                    ngg++; 
                }
            }
            if (bGetPupil(rr, ig, ngg, ijWFE[ig]))
            {
                int jx = ijWFE[ig][0]; 
                int jy = ijWFE[ig][1]; 
                MinFit.getABC(ngg, rr, jx, jy, 6, tiltWFE[ig]);

                //---finally apply this fit to the rays-----

                for (int k=1; k<=gnrays;  k++)
                  if (isRayOK[k] && (ig == iWFEgroup[k]))
                    dWFE[k] -= tiltWFE[ig][0]
                              + tiltWFE[ig][1]*dRays[k][gnsurfs][jx]
                              + tiltWFE[ig][2]*dRays[k][gnsurfs][jy];
            } 
        }
    } //----------finished with doWFEtable()-----------------------
*/


    static private boolean bGetBestPupil(double rr[][], int g, int n, int ij[])
    // Discovers which of {xy, xz, yz, uv, uw, vw} is the pupil. 
    {
        double big[] = new double[6];
        double wee[] = new double[6]; 
        for (int i=0; i<n; i++)
        {
           if (i==0)
             for (int j=0; j<6; j++)
               big[j] = wee[j] = rr[i][j]; 
           else
             for (int j=0; j<6; j++)
             {
                if (rr[i][j] > big[j])
                  big[j] = rr[i][j]; 
                else if (rr[i][j] < wee[j])
                  wee[j] = rr[i][j]; 
             }
        }

        double range[] = new double[6]; 
        for (int j=0; j<6; j++)
          range[j] = big[j] - wee[j]; 

        double area[] = new double[6]; 
        area[0] = range[0]*range[1];  // xy 
        area[1] = range[0]*range[2];  // xz
        area[2] = range[1]*range[2];  // yz
        area[3] = range[3]*range[4];  // uv
        area[4] = range[3]*range[5];  // uw
        area[5] = range[4]*range[5];  // vw

        double abiggest=area[0];
        int    kbiggest=0; 
        for (int k=1; k<6; k++)   // search for the pupil
          if (area[k]>abiggest)
          {
             abiggest = area[k];
             kbiggest = k;
          }

        if (abiggest < TOL)     // no pupil found.
        {
            ij[0] = ij[1] = 0; 
            return false; 
        } 

        switch (kbiggest)   // decode pupil variables
        {
            case 0: ij[0]=0; ij[1]=1; return true;  
            case 1: ij[0]=0; ij[1]=2; return true; 
            case 2: ij[0]=1; ij[1]=2; return true; 
            case 3: ij[0]=3; ij[1]=4; return true; 
            case 4: ij[0]=3; ij[1]=5; return true; 
            case 5: ij[0]=4; ij[1]=5; return true; 
        }
        return false; 
    } //----completes bGetBestPupil()--------











    static private int iCreateOneRandomRayStart()
    {
        // A207: sets up a random ray start as raystarts[0]
        // Called only by bRunOneRay(k) when k==0.
        // MUST NEVER RETURN ZERO.
        
        //---Set up user options for this ray trace; used below-------

        bUserOptionPositive = "T".equals(DMF.reg.getuo(UO_DEF, 3)); 
        for (int i=0; i<4; i++)
          if ("T".equals(DMF.reg.getuo(UO_DEF, 5+i)))
            iUserOptionMethod = i; 
        dIsoRadius = U.suckDouble(DMF.reg.getuo(UO_DEF,9)); 
        int nrays = DMF.giFlags[RNRAYS];

        //----Clear out entire ray zero from previous run------
        for (int j=0; j<=MAXSURFS; j++)
            for (int i=RX; i<RNSTARTS; i++)
                raystarts[0][i] = -0.0;

        //-----set up for distributions--------------

        boolean bXYZcontinuous = "T".equals(DMF.reg.getuo(UO_RAND,3)); 
        boolean bUVWcontinuous = "T".equals(DMF.reg.getuo(UO_RAND,5)); 
        boolean bUniform  = "T".equals(DMF.reg.getuo(UO_RAND, 7)); 
        boolean bCosine   = "T".equals(DMF.reg.getuo(UO_RAND, 8)); 
        boolean bBell     = "T".equals(DMF.reg.getuo(UO_RAND, 9)); 
        boolean bGauss    = "T".equals(DMF.reg.getuo(UO_RAND, 10)); 
        boolean bLorentz  = "T".equals(DMF.reg.getuo(UO_RAND, 11));  
        double  dConcen   = U.suckDouble(DMF.reg.getuo(UO_RAND, 12)); 
        dConcen = Math.max(1, dConcen); 
        int which = bCosine ? 1 : bBell ? 2 : bGauss ? 3: bLorentz ? 4 : 0;  
        
        // Choose a random table kray for color, wavel, order.
        int krand = (int) (nrays * Math.random() + 1.0); 

        //----Construct the random ray values XYZUVWP here-------------
     
        int krandxyz = (int) (nrays * Math.random() + 1.0);  
        for (int i=RX; i<=RZ; i++)
        {   
            boolean bAbsent = U.isNegZero(raystarts[krand][i]); 
            if (bAbsent)  // unspecified start
            {
                raystarts[0][i] = -0.0; 
            }
            else
            {
                if (bXYZcontinuous)        // continuous distribution
                   raystarts[0][i] = smins[i] + getRand(which, dConcen)*spans[i]; 
                else                       // discrete distribution
                   raystarts[0][i] = raystarts[krandxyz][i]; 
            }
        }  

        int kranduvw = (int) (nrays * Math.random() + 1.0);           
        for (int i=RU; i<=RW; i++)
        {   
            boolean bAbsent = U.isNegZero(raystarts[krand][i]); 
            if (bAbsent)  // unspecified start
            {
                raystarts[0][i] = -0.0; 
            }
            else
            {
                if (bUVWcontinuous)
                    raystarts[0][i] = smins[i] + getRand(which, dConcen)*spans[i]; 
                else
                    raystarts[0][i] = raystarts[kranduvw][i]; 
            }
        }  

        raystarts[0][RPATH] = raystarts[krand][RPATH]; 

        //-----Now have the random ray start----------------------
        //-----but still have -0.0 for absentee rays--------------
        //-----Fill in isotropic random direction cases next------


        double span = 1.0 - U.cosd(dIsoRadius); 
        switch(iUserOptionMethod)
        {
          case 0:  // volume  
             break;
          case 1:  // isotropic U0 
             {
                 double s = span * Math.random();
                 double p = U.TWOPI * Math.random(); 
                 double q = bUserOptionPositive ? 1-s : s-1; 
                 double r = Math.sqrt(1.0 - q*q); 
                 raystarts[0][RU] = q; 
                 raystarts[0][RV] = r * Math.cos(p); 
                 raystarts[0][RW] = r * Math.sin(p); 
             }
             break; 
          case 2:  // isotropic V0 
             {
                 double s = span * Math.random();
                 double p = U.TWOPI * Math.random(); 
                 double q = bUserOptionPositive ? 1-s : s-1; 
                 double r = Math.sqrt(1.0 - q*q); 
                 raystarts[0][RV] = q; 
                 raystarts[0][RU] = r * Math.cos(p); 
                 raystarts[0][RW] = r * Math.sin(p); 
             }
             break; 
          case 3: // isotropic W0
             {
                 double s = span * Math.random();
                 double p = U.TWOPI * Math.random(); 
                 double q = bUserOptionPositive ? 1-s : s-1; 
                 double r = Math.sqrt(1.0 - q*q); 
                 raystarts[0][RW] = q; 
                 raystarts[0][RU] = r * Math.cos(p); 
                 raystarts[0][RV] = r * Math.sin(p); 
             }
             break; 
        }
        fixupLabUVW(0); 
        // System.out.printf("RT13.iCreateRandomRay() using smins[RU]  = %8.4f \n", smins[RU]);
        // System.out.printf("RT13.iCreateRandomRay() using spans[RU]  = %8.4f \n", spans[RU]);
        // System.out.printf("RT13.iCreateRandomRay() has generated U0 = %8.4f \n", raystarts[0][RU]);
        // System.out.printf("RT13.iCreateRandomRay() has generated V0 = %8.4f \n", raystarts[0][RV]);
        // System.out.printf("RT13.iCreateRandomRay() has generated W0 = %8.4f \n", raystarts[0][RW]);
        return krand;
    }



    static private double getRand(int which, double dConcen)
    // returns 0<x<1 with various distribution densities.
    // dConcen = halfspan/width50; if =1, uniform.  
    {
        double uni = Math.random(); 
        dConcen = Math.max(1, dConcen);  
        if (dConcen<1.01)
          which = 0;   // adopt uniform
        switch(which)
        {
           case 0:  return uni;                            // uniform

           case 1:  return (1/Math.PI)*Math.acos(1-2*uni); // cosine

           case 2:  return bell(uni);                      // bell

           case 3:  double sigma=0.5/(1.349*(dConcen-1));  // Gaussian
                    double x=0.5;                     
                    boolean bOut=true; 
                    while (bOut)
                      {x = 0.5+sigma*U.grand(); bOut=(x>=1.)||(x<=0.); }
                    return x; 

           case 4:  double b = 4*dConcen - 4;              // Lorentzian
                    return 0.5+(1/b)*Math.tan((2*uni-1)*Math.atan(b/2)); 

           default: return uni;
        }
    }

    static private double bell(double p)
    // Bisection solver, 0=gBell(x)-p; 0<p<1, 0<x<1.
    {
        if ((p<0) || (p>1))
          return Double.NaN; 
        double a = 0.0;          // initial bracket
        double b = 1.0;          // initial bracket
        double c = 0.5*(a+b);    // initial center
        double funa = gBell(a)-p; 
        double funb = gBell(b)-p; 
        double func = gBell(c)-p; 

        for (int reps=0; reps<10; reps++)  // ten iters; err<0.001
        {
            if (funa*funb>0.0)
              return Double.NaN; 
            if (funa*func<=0.0)  // root in {a,c}; revise b and c.
            {
                 b = c; 
                 funb = func;
                 c = 0.5*(a+b); 
                 func = gBell(c)-p; 
            }
            else  // root in {c,b}; revise a and c.
            {
                 a = c; 
                 funa = func; 
                 c = 0.5*(a+b); 
                 func = gBell(c)-p; 
            }
        }
        return c; 
    }

    static private double gBell(double x)
    // returns cumulative probability 0<g<1 given 0<x<1, for bell() solver.
    // This is pieced together from two half quintics. 
    // Its probability density is a bell curve, two half quartics.
    {
        if ((x<0) || (x>1))
          return Double.NaN;
        if ((x==0) || (x==0.5) || (x==1))
          return x; 
        boolean bLower = true; 
        if (x>0.5)
        {
            bLower = false; 
            x = 1.-x; 
        }
        double y = (40./7.)*x*x*x - (48./7.)*x*x*x*x*x; 
        return bLower ? y : 1-y; 
    } 


    static private double dGetFunc(double ray[], double surf[])
    // Called by numNorm at six points in a tiny volume around intercept. 
    // Returns z-zsurf(x,y) for a neighborhood of the surface.
    // Relies upon class Z for its surface function library. 
    {
        double xyz[] = new double[3];  
        xyz[0] = ray[RTXL]; 
        xyz[1] = ray[RTYL]; 
        xyz[2] = Z.dGetZsurf(xyz[0], xyz[1], surf); 
        return ray[RTZL] - xyz[2]; 
    }


    static private void vPropagate(int kray, int jsurf, double d)
    // Propagates a ray for a distance d in vertex coordinate system.
    // Void because this cannot fail. 
    // Refractive index dI is needed only for RPATH. 
    {
        double dIndex = getRefraction(jsurf, kray); 
        dRays[kray][jsurf][RTXL] += dRays[kray][jsurf][RTUL] * d; 
        dRays[kray][jsurf][RTYL] += dRays[kray][jsurf][RTVL] * d; 
        dRays[kray][jsurf][RTZL] += dRays[kray][jsurf][RTWL] * d; 
        dRays[kray][jsurf][RPATH] += dIndex * d;
        if (surfs[jsurf][OTYPE] == OTDISTORT)
          dRays[kray][jsurf][RPATH] -= dRays[kray][jsurf][RTZL]; 
    }












    /*---------optical methods: interceptors & rootfinders--------*/
    /*---------optical methods: interceptors & rootfinders--------*/
    /*---------optical methods: interceptors & rootfinders--------*/
    
    static private int intercept(int kray, int jsurf)
    // calls dIntercept, propagates if OK: returns RR code: RROK, RRMIS, RRBAK, RRBRA
    {
        int code = RROK; 
        double d = dIntercept(dRays[kray][jsurf], surfs[jsurf]);
        if (d >= 0.0)
            vPropagate(kray, jsurf, d);
        else
            code = (int) Math.round(-d); // RRMIS=1, RRBAK=2, RRBRA=3
        // System.out.println("intercept is returning " + sResults[code]); 
        return code; 
    }
        

    static private double dIntercept(double ray[], double surf[])
    // Mathematical surface intercept test does not test Diameters. 
    // Returns  d>0 if an intercept can be identified.. 
    // RAY length = ZERO is VALID for plane surfaces;  (exactly zero? slightly negative?)
    // RAY length = ZERO is INVALID for curved surfaces. 
    // vPropagate() is called later if decision after result = RROK
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // Return values: RROK, -RRMIS, -RRBAK, -RRBRA. 
    {
        int iType = U.getInt(surf[OTYPE]);
        double dpro = surf[OPROFILE]; 
        int profile = U.getInt(dpro); 
        boolean rayok = isNormalizedVx(ray); 
        boolean bArray = ((iType==OTLENSARRAY) || (iType==OTMIRRARRAY)); // irisarray?
        double d = 0.0; 
        if (iType == OTIRISARRAY)
          d = dPlaneSolve(ray, surf); 
        else if (iType == OTCBOUT)
          d = 0.0;         
        else switch(profile)
        {
           case OSPLANO:   d = dPlaneSolve(ray, surf); break;
           case OSCONIC:
           case OSCONICLT:
           case OSCONICGT:
           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:
           case OSYCYL:
           case OSYCYLLT:
           case OSYCYLGT:  if (bArray)
                             d = dArrayQuadSolve(ray, surf);
                           else
                             d = dQuadSolve(0, 0, ray, surf);
                           break;
           case OSTORIC:
           case OSPOLYREV:
           case OSZERNREV:
           case OSZERNTOR: 
           case OSBICONIC: 
           case OSGAUSS: d = dNumSolve(ray, surf); 
                           break;
            default: System.out.println("RT13.dIntercept() has unknown profile = "+profile); 
            
        }
        if (Math.abs(d) < TOL)
          d = 0.0;
        return d; 
    }


    static private double dPlaneSolve(double ray[], double surf[])
    // Returns -RRMIS if ray is parallel to surface.
    // Returns -RRBAK if intercept is *definitely* backwards. 
    // ZERO=VALID is OK here. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2005, 2010
    {
        // System.out.printf("   RT13.dPlaneSolve() starting with RTWL = %12.6f \n", ray[RTWL]);
        boolean rayOK = isNormalizedVx(ray); 
        if (!rayOK)
            System.out.println("   RT13.dPlaneSolve() has an UNNORMALIZED ray.");
        if (Math.abs(ray[RTWL]) < TOL)
          return -RRMIS;            // negative code 
        double d = -ray[RTZL] / ray[RTWL]; 
        if (d < -TOL)
          return -RRBAK;
        if (d < TOL)
          return 0.0;
        return d; 
    }


    static private double dQuadSolve(double arrayox, double arrayoy, 
                              double ray[], double surf[])
    // Returns real positive root, or negative code number for failure. 
    // Handles conic, xcylinder, ycylinder cases, hints LT/GT/none.
    // ray[] is a 13-element array describing the ray start.
    // surf[] is a 122 parameter surface description
    // Offsets within an array: arrayox, arrayoy; zero for a single surface
    // Intercept policy from opro = surfs[OPROFILE] cases ">", "<" etc. 
    // ZERO=INVALID implemented here; permits SKIP.OPT
    // Rejects phantom hyperboloids and farside ellipsoids. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2007, 2012
    // Returns error codes -RRMIS, -RRBAK, -RRDIA, -RRSPI, ...
    {
        // System.out.println("Starting dQuadSolve().");
        boolean rayok = isNormalizedVx(ray); 
        double c, s, x, y, z, u, v, w, d;
        double[] dd = new double[2]; 
        double abc[] = new double[3]; 
        String report = ""; 

        //---initialize local shorthand variables-----------

        s = surf[OASPHER] + 1.0; 
        x = ray[RTXL] + arrayox;
        y = ray[RTYL] + arrayoy;
        z = ray[RTZL];
        u = ray[RTUL];
        v = ray[RTVL];
        w = ray[RTWL];

        int opro = (int) surf[OPROFILE]; 
        switch(opro)
        {
           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:  
               c = surf[OCURVX]; break; 
           default:        
               c = surf[OCURVE]; break; 
        } 

        //----------set up the appropriate quadratic form------

        switch(opro)
        {
           case OSCONIC:
           case OSCONICLT:
           case OSCONICGT:
                abc[0] = c*(u*u+v*v+s*w*w);
                abc[1] = 2*c*(x*u+y*v+s*z*w)-2*w;
                abc[2] = c*(x*x+y*y+s*z*z)-2*z;
                break; 

           case OSXCYL:
           case OSXCYLLT:
           case OSXCYLGT:
                abc[0] = c*(u*u+w*w);
                abc[1] = 2*c*(x*u+z*w)-2*w;
                abc[2] = c*(x*x+z*z)-2*z;
                break; 

           case OSYCYL:
           case OSYCYLLT:
           case OSYCYLGT:
                abc[0] = c*(v*v+s*w*w);
                abc[1] = 2*c*(y*v+s*z*w)-2*w;
                abc[2] = c*(y*y+s*z*z)-2*z;
                break; 
        }

        //-------get positive roots and test them-------------

        int nroots = iGetPosRoots(abc, dd); 
        
        // System.out.println("dQuadSolve nroots = "+nroots); 
        
        double  cz0 = c*(z+w*dd[0]);   // vxframe departure from plano
        double  cz1 = c*(z+w*dd[1]);   // vxframe departure from plano
        boolean E0  = s*cz0 < 1.0;     // existence check
        boolean E1  = s*cz1 < 1.0;     // existence check

        // System.out.printf("dQuadSolve cx0, cz1 = %6.3f  %6.3f \n", cz0, cz1);
        switch (nroots)
        {
            case -1:            // no real roots whatsoever
              return -RRMIS;    // negative error code

            case 0:             // no positive path roots
              return -RRBAK;    // negative error code

            case 1:            // one positive path root
              if (E0)  
                return dd[0];  //  Diameter test comes later
              else
                return -RRMIS;  // negative error code

            case 2:            // two positive path roots
              if (E0 && !E1)
                return dd[0];  // Diameter test immediately below
              if (!E0 && E1)
                return dd[1];  // Diameter test immediately below
              if (!E0 && !E1)
                return -RRMIS;  // negative error code
  
              //----both roots exist; test Diameters----------
              
              int D0 = testDiameter(dd[0], ray, surf);
              int D1 = testDiameter(dd[1], ray, surf); 
              
              if ((D0==RROK) && (D1!=RROK))  // one good intercept
                return dd[0]; 
              if ((D0!=RROK) && (D1==RROK))  // other good intercept
                return dd[1]; 
              if ((D0!=RROK) && (D1!=RROK))  // no good intercepts
                return -D0;   // return a negative error code
              
              if ((D0==RROK) && (D1==RROK))
                switch(opro)   // both roots are good so pick the preferred one
                {
                   case OSCONICGT:
                   case OSXCYLGT:   
                   case OSYCYLGT: return Math.max(dd[0], dd[1]);    // longer path

                   case OSCONICLT:
                   case OSXCYLLT:
                   case OSYCYLLT: return (cz0<cz1) ? dd[0] : dd[1]; // closer to vertex
                 
                   default:       return Math.min(dd[0], dd[1]);    // shorter path      
                }  
        }
        return -RRMIS;  // SNH; moved here thanks to Xlint 8 OCt 2014
    } //----------end dQuadsolve()--------------------


    static private int testDiameter(double d, double ray[], double surf[])
    // sets up a trial ray and returns an opinion from iDiams()
    // Returns RROK, RRDIA, RRIRI, RRSPI, etc
    {
        double trial[] = new double[13]; 
        for (int i=0; i<13; i++)
          trial[i] = ray[i]; 
        trial[RTXL] += trial[RTUL]*d; 
        trial[RTYL] += trial[RTVL]*d;
        trial[RTZL] += trial[RTWL]*d; 
        return iDiams(trial, surf); 
    }
    
    
    

    static private double dArrayQuadSolve(double ray[], double surf[])
    // Returns error codes -RRMIS, -RRBAK
    {
        double dx = surf[OODIAX]; 
        double dy = surf[OODIAY]; 
        int nx = (int) surf[ONARRAYX]; 
        int ny = (int) surf[ONARRAYY]; 
        if ((dx<=TOL) || (dy<=TOL) || (nx<1) || (ny<1))
        {
            return -RRMIS;
        } 
        double px = dx/nx;
        double py = dy/ny;
        double dBest = 9E99, dTest = -1.0;  
        int ix=0, iy=0; 
        for (int i=0; i<nx; i++)
        {
            double ox = (1.0-nx)*dx/(2.0*nx) + i*px; 
            for (int j=0; j<ny; j++)
            {
                double oy = (1.0-ny)*dy/(2.0*ny) + j*py; 
                dTest = dQuadSolve(ox, oy, ray, surf);
                if (dTest>0.0)
                {
                   double xx = ray[RTXL] + dTest*ray[RTUL]; 
                   double yy = ray[RTYL] + dTest*ray[RTVL]; 
                   boolean bCell = ((Math.abs(xx+ox) <= 0.5*px+TOL)
                                  && (Math.abs(yy+oy) <= 0.5*py+TOL)); 
                   if (bCell && (dTest<dBest))
                     dBest = dTest; 
                }
            }
        }     
        if (dBest>1E99)
          return -RRMIS;
        return dBest;  
    }

    static private double dNumSolve(double ray[], double surf[])
    // Returns propagation length if OK, else -1.0.
    // Relies upon Z.dGetZsurf() for the surface model. 
    // How to manage HINT for best efficiency?
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2005
    // Error: -RRBAK
    {
        double d[] = new double[2]; 
        if (bBracket(d, ray, surf))
        { 
            iBrent(d, ray, surf); 
            return d[0];
        }
        return -RRBAK;  // bracket fail is usually due to backward ray 
    }

    private static boolean bBracket(double d[], double r[], double s[])
    {
        int MAXIT1 = 10;       // allowed initial iterations for d[0]
        int MAXIT2 = 200;      // allowed fine iterations for d[1]
        double TINY = 1E-8;    // tiny compared to problem scale
        double FAST = 10.0;    // fast growth for d[0]
        double SLOW = 1.1;     // finesse d[1]; 1.1^200=>{1E-4,1E+4}
        double fa = 0.0; 

        //---- first, find d[0]: func(d[0]) is nonzero---------------

        d[0] = 0.0;            // initial guess
        int niter = 1; 
        while ((Math.abs(fa = zDiff(d[0],r,s)) < TOL) && (niter<MAXIT1))
        {
            niter++; 
            d[0] += TINY + FAST*d[0]; 
        }
        if (Math.abs(fa) < TOL)
        {
            return false;   
        }

        //----Then get d[1] alternating search around hint---
        //----Reject f(d[1])=0: could be a math failure----

        double hint = getHint(r); 
        d[1] = hint; 
        double p; 
        niter = 1; 
        while (((p = fa*zDiff(d[1],r,s)) >= 0.0) && (niter<MAXIT2))
        {
            niter++; 
            int j = (niter%2 == 0) ? niter/2 : -niter/2; 
            d[1] = hint * Math.pow(SLOW, j);  
        }
        if (p < 0)
          return true; 
        return false;        // failed to complete bracket. 
    } 


    static private double getHint(double ray[])
    {
        double d2 = ray[RTXL]*ray[RTXL] 
                  + ray[RTYL]*ray[RTYL] 
                  + ray[RTZL]*ray[RTZL]; 
        return 0.2*DMF.getOsize() + 0.8*Math.sqrt(d2);
    }


    private static int iBrent(double t[], double ray[], double surf[])
    //  Given a bracket (t[0], t[1]), Brent() sets t[0] to root,
    //  and returns the number of calls to zDiff() taken.
    //  Relies upon Z.dGetZsurf() for the surface model. 
    //  Press et al NUMERICAL RECIPES IN C 2nd edition 1992 p.361
    //  R.P.Brent ALGORITHMS... Prentice-Hall, NJ 1973.
    {
        int MAXIT = 50; 
        double a, b, c, d=0, e=0, min1, min2;
        double fc, p, q, r, s, toler, xm, fa, fb;
        a=t[0]; 
        b=c=t[1];
        fa=zDiff(a, ray, surf);
        fb=zDiff(b, ray, surf);
        if (fa*fb > 0)
          return -1; // bad starting bracket
        fc = fb;
        for (int iter=1; iter<MAXIT; iter++)
        {
            if (fb*fc > 0)
            {
                c = a;
                fc = fa;
                e = d = b-a;
            }
            if (Math.abs(fc) < Math.abs(fb))
            {
                a = b;
                b = c;
                c = a;
                fa = fb;
                fb = fc;
                fc = fa;
            }
            toler = 2.0 * TOL * Math.abs(b) + TOL;
            xm = 0.5*(c-b);
            t[0] = b;     // return value
            if ((Math.abs(xm) <= toler) || (fb == 0.0))
              return iter;
            if ((Math.abs(e) >= toler) && (Math.abs(fa) > Math.abs(fb)))
            {
                s = fb/fa;
                if (a == c)
                {
                    p = 2.0*xm*s;
                    q = 1.0-s;
                }
                else
                {
                    q = fa/fc;
                    r = fb/fc;
                    p = s*(2.0*xm*q*(q-r) - (b-a)*(r-1.0));
                    q = (q-1.0)*(r-1.0)*(s-1.0);
                }
                if (p > 0.0)
                  q = -q;
                p = Math.abs(p);
                min1 = 3.0*xm*q - Math.abs(toler*q);
                min2 = Math.abs(e*q);
                if (2.0*p < (min1 < min2 ? min1 : min2))
                {
                    e = d;
                    d = p/q;
                }
                else
                {
                    d = xm;
                    e = d;
                }
            }
            else
            {
                d = xm;
                e = d;
            }
            a = b;
            fa = fb;
            if (Math.abs(d) > toler)
              b += d;
            else
              b += (xm > 0.0) ? Math.abs(toler) : -Math.abs(toler);
            fb = zDiff(b, ray, surf);
        }
        return MAXIT; // SNH
    }


    static private double zDiff(double d, double ray[], double surf[])
    // This is the engine that is called by bBracket() and iBrent().
    // Returns the z-component of discrepancy ray-surface.
    // Relies upon Z.dGetZsurf() for the surface model. 
    {
        double xyz[] = new double[3]; 
        xyz[0] = ray[RTXL] + ray[RTUL]*d; 
        xyz[1] = ray[RTYL] + ray[RTVL]*d; 
        xyz[2] = Z.dGetZsurf(xyz[0], xyz[1], surf); 
        return ray[RTZL] + ray[RTWL]*d - xyz[2];
    }









    /*--------------------Diameters-------------------*/
    /*--------------------Diameters-------------------*/
    /*---A207 eliminating special code for iris-------*/


    static private int validate(int kray, int jsurf)
    {
        int code = iDiams(dRays[kray][jsurf], surfs[jsurf]);
        // System.out.println("Validate is returning " + sResults[code]);
        return code; 
    }

    static private int iDiams(double ray[], double surf[])
    // Returns RROK if ok, else a positive failure code RRDIA, RRiri, etc.
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003, 2013
    {
        boolean bIRect = ((OFIRECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        boolean bORect = ((OFORECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        
        if (OTIRISARRAY == surf[OTYPE])
          return iIrisArray(ray, surf); 

        //---do the inner edge first-------
        
        double x = ray[RTXL] - surf[OFFIX];  // eccentric frame
        double y = ray[RTYL] - surf[OFFIY];  // eccentric frame
        double diay = surf[OIDIAY]; 
        double diax = surf[OIDIAX]; 

        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            
            // if both are too small, we fall into the hole:
            
            boolean bhole = bIRect ? Math.max(sx,sy)<1.0 : sx+sy<1.0;
            if (bhole)
              return RRdia;    
        }

        //-----do the outer edge--------
        
        x = ray[RTXL] - surf[OFFOX];  // eccentric frame
        y = ray[RTYL] - surf[OFFOY];  // eccentric frame
        diay = surf[OODIAY]; 
        diax = surf[OODIAX]; 
        if (U.isNegZero(diax))
          diax = diay; 
        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            
            // if either is too big, we fall off the edge:

            boolean bedge = bORect ? Math.max(sx,sy)>1.0 : sx+sy>1.0;
            if (bedge)
              return RRDIA;
        }

        // Now do the spider legs in X,Y plane
        // Leg zero lies along the X axis.  
        // We rotate the ray, not the rectangle.
        int nlegs = (int) surf[ONSPIDER];
        if (nlegs > 0)
        {
            double halfleg = 0.5 * surf[OWSPIDER]; 
            double radius = Math.sqrt(x*x + y*y); 
            if (radius < halfleg)
              return RRSPI; 
            double angle = Math.atan2(y, x);
            double dangle = TWOPI/nlegs; 
            while (nlegs > 0)
            {
                x = radius * Math.cos(angle); 
                y = radius * Math.sin(angle); 
                if ((x>0.0) && (Math.abs(y)<halfleg))
                  return RRSPI; 
                nlegs--; 
                angle += dangle; 
            }
        }
        return RROK; 
    }

    static private int iIrisArray(double ray[], double surf[])
    // Returns RROK or RRIRI or RRDIA.
    // Model: infinite plane barrier with holes.
    //    ** Within Rinner, ray passes with  RROK;
    //    ** Beyond Router, ray dies with RRDIA;
    //    ** In between, ray dies with RRdia
    // M.Lampton STELLAR SOFTWARE (C) 2007
    {
        boolean bIRect = ((OFIRECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));
        boolean bORect = ((OFORECT==surf[OFORM]) || (OFBRECT==surf[OFORM]));

        // do the outer edge first
        double x = ray[RTXL] - surf[OFFOX];  // eccentric frame
        double y = ray[RTYL] - surf[OFFOY];  // eccentric frame
        double diay = surf[OODIAY]; 
        double diax = surf[OODIAX]; 
        if (U.isNegZero(diax))
          diax = diay; 
        if ((diax > TOL) && (diay > TOL))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            // if either is too big, we bypass the outer edge:
            if (bORect && (Math.max(sx, sy) > 1.0))
              return RRDIA; 
            if (!bORect && (sx + sy > 1.0))
              return RRDIA; 
        }

        // inner edge next; but use Outer Offsets. 

        x = Z.dSawtoothX(x, surf); 
        y = Z.dSawtoothY(y, surf); 

        diay = surf[OIDIAY];   // inner diam
        diax = surf[OIDIAX];   // inner diam
        if (U.isNegZero(diax)) 
          diax = diay; 

        if ((diax > TINY) && (diay > TINY))
        {
            double sx = 4 * x*x/(diax*diax); 
            double sy = 4 * y*y/(diay*diay); 
            // if either is too big, we hit the mask:
            if (bIRect && (Math.max(sx, sy) > 1.0))
              return RRdia; 
            if (!bIRect && (sx + sy > 1.0))
              return RRdia;  
        }
        return RROK; 
    }








    /*-------------------------redirectors----------------------*/
    /*-------------------------redirectors----------------------*/
    /*-------------------------redirectors----------------------*/
    
    static private int redirect(int kray, int jsurf)
    // attempts to redirect a ray segment; returns RROK or error code
    {
        // System.out.println("RT13.redirect() is given kray, jsurf = "+kray+"  "+jsurf); 
        int code = iRedirect(dRays[kray], surfs[jsurf], jsurf);
        // System.out.println("RT13.redirect is returning " + sResults[code]);
        return code;
    }


    static private int iRedirect(double rayseq[][], double surf[], int j)
    // M.Lampton STELLAR SOFTWARE (C) 2013
    //
    // Modifies the local-frame u,v,w to redirect this ray. 
    // Receives jsurf needed for getRefraction() towards next surface.
    // Works entirely in the local frame. 
    // Requires group "g" to properly index rayseq[]
    // Receives status from preceding Diam() check. 
    // Returns RROK, RRUNK, RRORD, RRTIR. 
    {
        vSetAngle(rayseq[j], surf);  // sets incoming RTANGLE fields before modifying ray direction
        boolean bGroovy = surf[OGROOVY] != 0.0; 
        int surftype = (int) surf[OTYPE]; 
        switch(surftype)
        {
             case OTBLFRONT:      // successful refraction at bimodal lens
             case OTBLBACK:
                    return iTG(rayseq[j], surf, j); 
             case OTBMIRROR:
                    return iMirror(rayseq[j], surf);
             case OTDISTORT:
                    return RROK; 
             case OTIRIS: 
             case OTIRISARRAY:
                    return RROK; // no redirection needed.  
             case OTRETRO: 
                    return iRetro(rayseq[j], surf); 
             case OTMIRROR:
             case OTMIRRARRAY:
                    if (bGroovy) 
                      return iRgrating(rayseq[j], surf);
                    else
                      return iMirror(rayseq[j], surf); 
             case OTLENS:
             case OTLENSARRAY:
                    return iTG(rayseq[j], surf, j); 
             case OTGSCATTER:
                    return iGScatter(rayseq[j], surf);   // A195
             case OTUSCATTER:
                    return iUScatter(rayseq[j], surf);   // A195
             case OTCBIN:      // CoordBreak input surface
                    return iCBIN(rayseq, surf, j);  // copy previous local uvw
             case OTCBOUT:     // CoordBreak output surface 
                    return iCBOUT(rayseq, surf, j); // copy previous local xyzuvw
             case OTTERMINATE:  // ray killer MUST BECOME BIMODAL
                     return RRTER; 
             case OTTHIN:  // Thin Lens case
                     return iThin(rayseq[j],surf);
        }
        return RRUNK; 
    }
    
    
        
    static private int iCBIN(double rayseq[][], double surf[], int g)
    // CoordBreak CBin input surface method
    // Must do nothing: CBout will grab local coords here.
    {
        return RROK; 
    }
    
    static private int iCBOUT(double rayseq[][], double surf[], int g)
    // CoordBreak CBout output surface method
    // Must copy previous local xyzuvw into this local surface.
    {
        if (g>1)
        {
            rayseq[g][RTXL] = rayseq[g-1][RTXL]; 
            rayseq[g][RTYL] = rayseq[g-1][RTYL]; 
            rayseq[g][RTZL] = rayseq[g-1][RTZL]; 
            rayseq[g][RTUL] = rayseq[g-1][RTUL]; 
            rayseq[g][RTVL] = rayseq[g-1][RTVL]; 
            rayseq[g][RTWL] = rayseq[g-1][RTWL]; 
        }
        return RROK; 
    }

    static private int iThin(double ray[], double surf[])
    // Jaime García @gvJaime 2019
    // Ray tracing according to thin lens hypothesis.
    {
      double focal = 1 / surf[OFOCAL];
      int sign = (int) Math.signum(focal);
      double[] r = new double[3];
      double d;
      d = focal / ray[RTWL];
      r[0] = ray[RTUL] * d - ray[RTXL];
      r[1] = ray[RTVL] * d - ray[RTYL];
      r[2] = focal;
      d = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
      ray[RTUL] = sign * r[0] / d;
      ray[RTVL] = sign * r[1] / d;
      ray[RTWL] = sign * r[2] / d;
      return RROK; 
    }

    static private int iMirror(double ray[], double surf[])
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // method: r = i - 2 (i dot n) n
    // note this is quadratic in n, hence independent of sign(n)
    {
        double[] Norm = new double[RNATTRIBS];
        vGetPerp(ray, surf, Norm); 
        double dotin = ray[RTUL]*Norm[RTUL] + ray[RTVL]*Norm[RTVL] + ray[RTWL]*Norm[RTWL];
        ray[RTUL] -= 2.0 * dotin * Norm[RTUL];
        ray[RTVL] -= 2.0 * dotin * Norm[RTVL];
        ray[RTWL] -= 2.0 * dotin * Norm[RTWL];
        // normalize(ray);   // should be unnecessary!
        return RROK;
    }


    static private void vSetAngle(double ray[], double surf[])
    // M.Lampton STELLAR SOFTWARE (C) 2015
    // uses iMirror() tools to get any intercept ray dot normal.
    // called by iRedirect for good rays, fills in ray[RTANGLE] and normal {i,j,k}.
    // Oct 2015: now using Triple::getAngle() full accuracy. 
    {
        double[] nor = new double[RNATTRIBS];
        vGetPerp(ray, surf, nor); 
        Triple R = new Triple(ray[RTUL], ray[RTVL], ray[RTWL]); 
        Triple N = new Triple(nor[RTUL], nor[RTVL], nor[RTWL]); 
        double degrees = Math.toDegrees(Triple.getAngle(R, N));
        if (degrees > 90.0)            // if farside
          degrees = 180.0 - degrees;   // use nearside
        // finally, fill in the angle fields of ray[]
        ray[RTANGLE] = degrees; 
        ray[RTNORMX] = nor[RTUL]; 
        ray[RTNORMY] = nor[RTVL]; 
        ray[RTNORMZ] = nor[RTWL]; 
    }

    
    static private int iRetro(double ray[], double surf[])
    {
        ray[RTUL] *= -1.0; 
        ray[RTVL] *= -1.0; 
        ray[RTWL] *= -1.0; 
        return RROK; 
    }
    

    static private int iSnell(double ray[], double surf[], int jsurf)
    // Caution: ray[13] is solved in local frame. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    // Method: S' = mu * Salongsurface + gamma * Normaltosurface,
    //   where mu = Nin/Nout; and gamma completes the square. 
    // Spencer & Murty JOSA 52#6 672 1962.
    // Refractive indices can be positive or negative.
    {
        double numer, denom, mu, ax, ay, az, bx, by, bz, b2, gamma, dotin;

        int kray = getGuideRay(); 
        System.out.println("iSnell called getGuideRay() and has got " + kray);
        numer = getRefraction(jsurf, kray); 
        denom = getRefraction(jsurf+1, kray); 

        if (Double.isNaN(numer) || (numer==0.0))
          numer = 1.0; 
        if (Double.isNaN(denom) || (denom==0.0))
          denom = 1.0; 

        mu = numer/denom;
        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        /// A is mu * (ray cross norm), perpendicular to {S,N} plane
        ax = mu * (ray[RTVL]*Norm[RTWL] - ray[RTWL]*Norm[RTVL]);  
        ay = mu * (ray[RTWL]*Norm[RTUL] - ray[RTUL]*Norm[RTWL]); 
        az = mu * (ray[RTUL]*Norm[RTVL] - ray[RTVL]*Norm[RTUL]); 

        // B is (N cross A) = mu*ray projected along surface, in {S,N} plane
        bx = Norm[RTVL]*az - Norm[RTWL]*ay;  
        by = Norm[RTWL]*ax - Norm[RTUL]*az; 
        bz = Norm[RTUL]*ay - Norm[RTVL]*ax;

        b2 = bx*bx + by*by + bz*bz;
        if (b2 > 1.0)
          return RRTIR;
        if (b2  < 1.0)
          gamma = Math.sqrt(1 - b2);
        else
          gamma = 0.0;
        dotin = ray[RTUL]*Norm[RTUL] + ray[RTVL]*Norm[RTVL] + ray[RTWL]*Norm[RTWL];
        if (dotin < 0.0)
          gamma = -gamma;
        ray[RTUL] = bx + gamma * Norm[RTUL];
        ray[RTVL] = by + gamma * Norm[RTVL];
        ray[RTWL] = bz + gamma * Norm[RTWL];
        return RROK;
    }


    static private void getG(double ray[], double surf[], double G[])
    // evaluates local groove density. Returns G[0]=gx, G[1]=gy.
    {
        double x = ray[RTXL]; 
        double x2 = x*x; 
        double x3 = x2*x;
        double x4 = x2*x2; 
        double y = ray[RTYL]; 
        double y2 = y*y;
        double y3 = y2*y; 
        double y4 = y2*y2; 
                    
        double gx = surf[OGX] + x*surf[OVX10] + x2*surf[OVX20] + x3*surf[OVX30] + x4*surf[OVX40]
                 + y*surf[OVX01] + y2*surf[OVX02] + y3*surf[OVX03] + y4*surf[OVX04]
                 + x*y*surf[OVX11] + x*y2*surf[OVX12] +x*y3*surf[OVX13]
                 + x2*y*surf[OVX21] + x2*y2*surf[OVX22] + x3*y*surf[OVX31]; 
                        
        double gy = surf[OGY] + x*surf[OVY10] + x2*surf[OVY20] + x3*surf[OVY30] + x4*surf[OVY40]
                + y*surf[OVY01] + y2*surf[OVY02] + y3*surf[OVY03] + y4*surf[OVY04]
                + x*y*surf[OVY11] + x*y2*surf[OVY12] + x*y3*surf[OVY13]
                + x2*y*surf[OVY21] + x2*y2*surf[OVY22] + x3*y*surf[OVY31]; 
                        
        if (Math.abs(surf[OHOELAM]) > TOL)    // add HOE terms.....
        {
            double d1 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX1])
                                  + U.sqr(ray[RTYL] - surf[OHOEY1])
                                  + U.sqr(ray[RTZL] - surf[OHOEZ1]));
 
            double d2 = Math.sqrt(  U.sqr(ray[RTXL] - surf[OHOEX2])
                                    + U.sqr(ray[RTYL] - surf[OHOEY2])
                                    + U.sqr(ray[RTZL] - surf[OHOEZ2]));

            if ((d1 > TOL) && (d2 > TOL))
            {
                double a1 = 1.0 / (d1*surf[OHOELAM]);     // virtual HOE if <0
                double a2 = 1.0 / (d2*surf[OHOELAM]);
                gx += a1*(ray[RTXL]-surf[OHOEX1])-a2*(ray[RTXL]-surf[OHOEX2]);
                gy += a1*(ray[RTYL]-surf[OHOEY1])-a2*(ray[RTYL]-surf[OHOEY2]);
            }
        }       
        G[0] = gx;
        G[1] = gy;                 
    }

    static private int iTG(double ray[], double surf[], int jsurf)
    // Plane Transmission grating solver: refraction and diffraction combined.
    // Must have numerical wavelength not literal if using diffraction. 
    //
    // Could replace iSnell() !
    //
    // Has VPHs and HOEs.
    // M.Lampton STELLAR SOFTWARE (C) 2015  rev A186, A194
    // Spencer & Murty JOSA 52#6 672 (1962) eqn 49, three terms in local frame
    // Refraction of incoming ray S...
    //    S' = (n2/n1)*S 
    // plus diffraction into the local P direction perp to grooves...
    //    + (M*G*lambda/n2)*P 
    // plus a normal part to complete the square...
    //    + gamma*r. 
    // Note: bGroovy triggers for any param GX....ORDER..VLS.....HOELAM being present. 
    //
    // Refractive indices can be positive or negative.
    {   
        int kray = getGuideRay(); 
        double numer = getRefraction(jsurf, kray); 
        double denom = getRefraction(jsurf+1, kray); 

        if (Double.isNaN(numer) || (numer==0.0))
          numer = 1.0; 
        if (Double.isNaN(denom) || (denom==0.0))
          denom = 1.0; 

        double mu = numer/denom;
        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        /// PART ONE: evaluate the refraction perp to Norm:
        
        Triple Ray   = new Triple(ray[RTUL],  ray[RTVL],  ray[RTWL]); 
        Triple Unorm = new Triple(Norm[RTUL], Norm[RTVL], Norm[RTWL]); 
        // unit length guaranteed by Z.normalize()
          
        Triple Total = Triple.getPerp(Ray, Unorm);       // pure refraction so far
        Total = Triple.getProduct(Total, mu);           // modified by refractive ratio

        /// PART TWO: evaluate the local plane diffraction if any:
        
        // Get order from raystart, or if absent, from the optic table. 
        double order = surf[OORDER]; 
        double rayorder = raystarts[kray][RSORDER]; 
        if (U.isNotNegZero(rayorder))
          order = rayorder;
        if (order != 0)                // diffractive?
        {
            double wavel = raystarts[kray][RSWAVEL]; 
            if (Double.isNaN(wavel))
              return RRUNK; 
              
            double waveorder = wavel*order; 

            if (waveorder != 0.)       // If it is wavy...
            {
                double G[] = new double[2]; 
                getG(ray, surf, G);
                Triple Grating = new Triple(G[0], G[1], 0.);       // in vertex frame
                Triple Diffract = Triple.getPerp(Grating, Unorm);  // in vertex frame
                double coef = waveorder/denom;                     // scaling factor
                Grating = Triple.getProduct(Grating, coef);        // in vertex frame
                Total = Triple.getSum(Total, Grating);             // now with diffraction if present.  
            }
        }
        
        // The gamma term to make |S|=1 is purely along the normal.
        // The S components from refraction and diffraction are purely perp normal.
        // So THERE IS NO NEED FOR A NUMERICAL GAMMA SOLVER, just apply total squares,
        // to make the magnitude of S come out to equal 1.
        //
        ///// NOW MODIFY THE RAY DIRECTION IN FULL 3D ///
        
        double rlength = Total.getLength(); 
        double r2 = rlength*rlength; 
        if (r2 > 1.0)
          return RRTIR;  // could also be RRORDER
        double gamma = Math.sqrt(1 - r2); 
        double dotin = Triple.getDot(Ray, Unorm); 
        if (dotin < 0.0)
          gamma = -gamma;
        ray[RTUL] = Total.getX() + gamma * Unorm.getX();
        ray[RTVL] = Total.getY() + gamma * Unorm.getY();
        ray[RTWL] = Total.getZ() + gamma * Unorm.getZ();  
        return RROK;
    }




    static private int iGScatter(double ray[], double surf[])  
    // A196: scatter is with respect to local normal not incoming ray direction
    {
        double[] Norm = new double[RNATTRIBS];
        vGetPerp(ray, surf, Norm);     
        double radians = (Math.PI/180.0) * surf[OSCATTER]; // get the Gaussian scatter angle
        // ray[RTUL] += radians * U.grand();               // add to previous ray direction
        // ray[RTVL] += radians * U.grand();               // add to previous ray direction
        // ray[RTWL] += radians * U.grand();               // add to previous ray direction
        ray[RTUL] = Norm[RTUL] + radians * U.grand();      // deviate from local normal
        ray[RTVL] = Norm[RTVL] + radians * U.grand();      // deviate from local normal
        ray[RTWL] = 1.;
        double sum = U.sqr(ray[RTUL]) + U.sqr(ray[RTVL]) + U.sqr(ray[RTWL]); 
        sum = Math.sqrt(sum); 
        ray[RTUL] /= sum;  
        ray[RTVL] /= sum; 
        ray[RTWL] /= sum;
        return RROK; 
    }
    
    static private int iUScatter(double ray[], double surf[])  // A195 uniform scatter
    // A196: scatter is with respect to local normal not vertex normal
    {
        double[] Norm = new double[RNATTRIBS];
        vGetPerp(ray, surf, Norm); 
        double azimuth = 2*Math.PI * Math.random(); 
        double maxdeg = Math.max(0., Math.min(89.99, surf[OSCATTER]));
        double maxradians = (Math.PI/180.)* maxdeg;
        double radius = Math.sqrt(Math.random())*maxradians; 
        ray[RTUL] = Norm[RTUL] + radius*Math.cos(azimuth); 
        ray[RTVL] = Norm[RTVL] + radius*Math.sin(azimuth); 
        ray[RTWL] = 1.;
        double sum = U.sqr(ray[RTUL]) + U.sqr(ray[RTVL]) + U.sqr(ray[RTWL]); 
        sum = Math.sqrt(sum); 
        ray[RTUL] /= sum;  
        ray[RTVL] /= sum; 
        ray[RTWL] /= sum;
        return RROK; 
    }

    static private int iRgrating(double ray[], double surf[])
    {
        return iGrating(ray, surf, true); 
    }


    static private int iGrating(double ray[], double surf[], boolean bRefl)
    // Vacuum diffraction grating, transmission or reflection. 
    //   Output: revised ray[] directions in local vertex frame.
    //   Method: Spencer & Murty eqns 49 & 50.
    //
    // Given incident propagator Ki and emergent propagator Ke,
    // boundary condition sets two wave matching conditions. {x,y} are in surface:
    //      Kxe = Kxi + 2pi*order*gx
    //      Kye = Kyi + 2pi*order*gy
    // and wave frequency match sets....
    //     |Ke| = |Ki|*v1/v2 = |Ki|*n2/n1.
    //
    // May 2013: better is to include Spencer & Murty's refraction.  Unit ray directions S1, S2:
    //      S2 x Normal = (n1/n2)* S1 x Normal + M*G*lambda**Q/n2
    // where Q is the unit vector parallel to local rulings. 
    // Sept 2015 A186 doing this implementation
    //
    //
    // Let P, Q, R be unit vectors: perp groove, along groove, local normal;
    // let iP, iQ, iR be incident ray direction,
    // let eP, eQ, eR be emergent ray direction,
    // then  eP = iP - order * lambda * g;
    // and   eQ = iQ;
    // then  eR must complete the trio, making |e|=1
    //     sign(eR) = sign(iR) for transmission
    //     sign(eR) = -sign(iR) for reflection.
    // The sign of "order" depends on the sign of P adopted.  Here,
    // I use Px<0 if Gx>0 and Py<0 if Gy>0, so that positive order
    // corresponds to decreasing eP, increasing eU and increasing eV.
    // 
    // Holographic optical elements (HOEs) are computed the same way as
    // classical gratings, except the local groove frequency vector gx gy gz
    // is computed from grad(PathDifference)/HOELambda, using the fact that
    // when the path difference is an integer number of lambda we have local
    // constructive interference and a groove, but when it is half
    // of a wavelength we have destructive interference and no groove. 
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003 
    {
        double qx, qy, qz, qq, absRxG, px, py, pz, sp, sq, sr, sr2;
        double gx, gy, diffract, a1, a2, d1, d2;
        double dAction = bRefl ? -1.0 : 1.0; // -1=reflect; +1=transmit VACUUM ONLY

        // Get the ray wavelength from this raystart. 

        int kray = getGuideRay(); 
        double wavel = raystarts[kray][RSWAVEL]; 
        if (Double.isNaN(wavel))
          return RRUNK; 

        // Get the diffraction order from this raystart,
        // or if absent, from the optic table. 
        double order = surf[OORDER]; 
        double rayorder = raystarts[kray][RSORDER]; 
        if (U.isNotNegZero(rayorder))
          order = rayorder;

        double waveorder = wavel*order;   
        if (waveorder == 0.0)
        {
            if (bRefl)
              return iMirror(ray, surf);
            else
              return RROK;
        }

        double G[] = new double[2];  // groove density in x,y
        getG(ray, surf, G); 
        
        // Get the unit groove vector Q in vertex coords.
        // Method: Q = Norm cross G
        // Caution: Q must be a unit vector, even if G is zero, because it will
        // be the foundation of the PQR coordinate system for diffraction.
        // Get the diffraction quantity also.
        // Start with the local surface normal:

        double[] Norm = new double[13]; 
        vGetPerp(ray, surf, Norm); 

        qx = -Norm[RTWL] * G[1];
        qy =  Norm[RTWL] * G[0];
        qz =  Norm[RTUL] * G[1] - Norm[RTVL] * G[0];

        // normalize these
        qq = U.sqr(qx) + U.sqr(qy) + U.sqr(qz); 
        if (qq > TOL)
        {
            qq = Math.sqrt(qq); 
            qx /= qq; 
            qy /= qq; 
            qz /= qq; 
        }
        else  // g=0, nothing to diffract
        {
            if (bRefl)
              return iMirror(ray, surf);  // reflect without diffracting
            else
              return RROK;                // transmit unchanged
        }

        // Get the local groove perpendicular P in vertex coordinates

        px = qy * Norm[RTWL] - qz * Norm[RTVL];   // P = Q x R = groove perp
        py = qz * Norm[RTUL] - qx * Norm[RTWL];
        pz = qx * Norm[RTVL] - qy * Norm[RTUL];

        // Get the incident ray direction in local groove coordinates:

        sp = px*ray[RTUL] + py*ray[RTVL] + pz*ray[RTWL];  // incident dot grooveperp
        sq = qx*ray[RTUL] + qy*ray[RTVL] + qz*ray[RTWL];  // incident dot groove
        sr = Norm[RTUL]*ray[RTUL] + Norm[RTVL]*ray[RTVL] + Norm[RTWL]*ray[RTWL];  // incident dot normal
        double posdot = (sr >= 0.0) ? 1.0 : -1.0; 

        // Diffract the ray in local grating coordinates

        diffract = order * wavel * qq;
        sp = sp + diffract;
        sr2 = 1.0 - U.sqr(sp) - U.sqr(sq); 
        if (sr2 < 0.0)
          return RRORD;

        sr = dAction * posdot * Math.sqrt(sr2); 

        // Put the ray back into vertex coordinates
        ray[RTUL] = sp*px + sq*qx + sr*Norm[RTUL];
        ray[RTVL] = sp*py + sq*qy + sr*Norm[RTVL];
        ray[RTWL] = sp*pz + sq*qz + sr*Norm[RTWL];

        if (!isNormalizedVx(ray))
          U.beep();  // nonnormalized output. 

        return RROK;
    }





    /*-------------vGetPerp finds the perp for any surface------------*/
    /*---------------it always calls Z.vGetNormal()--------------------*/

    static private void vGetPerp(double ray[], double surf[], double p[])
    // ray[13]; surf[121]; perp[13] is in local frame RTUL, RTVL, RTWL. 
    // This converts ray from 13-dim space in RT13 to 3-Dim space of Z.
    // Then, converts perp "q" from 3-Dim to 13-dim space for RT13. 
    {
        double q[] = new double[3]; 
        Z.vGetNormal(ray[RTXL], ray[RTYL], surf, q); 
        p[RTUL] = q[0];
        p[RTVL] = q[1];
        p[RTWL] = q[2];  // USUALLY NEGATIVE.  WHY? 
        double soserr = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] - 1.0; 
    }



    /*-----------------some coordinate changing utilities--------------------*/
    /*-----------------some coordinate changing utilities--------------------*/
    /*-----------------some coordinate changing utilities--------------------*/


    
    static private void labtovx(int k, int jprev, int j)
    // Coordinate frame changer from lab jprev to vertex frame j.
    // Matrix OE converts local to lab coordinates; so use its transpose here.
    // Also carries RPATH forward from rprev[] to rthis[] ??
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003
    {
        double x, y, z, dx, dy, dz, u, v, w;
        boolean rayok = isNormalizedLab(dRays[k][jprev]);
        if (!rayok)
        {
            System.out.println("labtovx() starting with BAAD LAB NORMALIZATION; k, jprev, j= "+k+"  "+jprev+"  "+j);
            System.out.println("....norm error = "+getNormErrorLab(dRays[k][jprev])); 
        }
        
        x  = dRays[k][jprev][RX];
        y  = dRays[k][jprev][RY];
        z  = dRays[k][jprev][RZ];    
        u  = dRays[k][jprev][RU];
        v  = dRays[k][jprev][RV];
        w  = dRays[k][jprev][RW];            
        // System.out.printf("labtovx input  x,y,z,u,v,w = %8.4f %8.4f %8.4f %8.4f %8.4f %8.4f \n", x,y,z,u,v,w);             
        
        dx = dRays[k][jprev][RX] - surfs[j][OX];
        dy = dRays[k][jprev][RY] - surfs[j][OY];
        dz = dRays[k][jprev][RZ] - surfs[j][OZ];
   
        dRays[k][j][RTXL] = surfs[j][OE11]*dx + surfs[j][OE21]*dy + surfs[j][OE31]*dz;
        dRays[k][j][RTYL] = surfs[j][OE12]*dx + surfs[j][OE22]*dy + surfs[j][OE32]*dz;
        dRays[k][j][RTZL] = surfs[j][OE13]*dx + surfs[j][OE23]*dy + surfs[j][OE33]*dz;
        
        dRays[k][j][RTUL] = surfs[j][OE11]*u + surfs[j][OE21]*v + surfs[j][OE31]*w;
        dRays[k][j][RTVL] = surfs[j][OE12]*u + surfs[j][OE22]*v + surfs[j][OE32]*w;
        dRays[k][j][RTWL] = surfs[j][OE13]*u + surfs[j][OE23]*v + surfs[j][OE33]*w;
        dRays[k][j][RPATH] = dRays[k][jprev][RPATH]; 
        
        x  = dRays[k][j][RTXL];
        y  = dRays[k][j][RTYL];
        z  = dRays[k][j][RTZL];    
        u  = dRays[k][j][RTUL];
        v  = dRays[k][j][RTVL];
        w  = dRays[k][j][RTWL];          
        // System.out.printf("labtovx output x,y,z,u,v,w = %8.4f %8.4f %8.4f %8.4f %8.4f %8.4f \n", x,y,z,u,v,w);        
    }


    static private void vxtolab(int k, int j)
    // Coordinate frame changer, ray="k", single surface "j".
    // Here the OE matrix is used directly, local to lab conversion. 
    // Converts a vertex-frame ray descriptor to lab frame.
    // M.Lampton STELLAR SOFTWARE (C) 1989, 2003
    {
        double x, y, z, u, v, w;
        
        boolean rayok = isNormalizedVx(dRays[k][j]);
        if (!rayok)
        {
            System.out.println("vxtolab() starting with BAAD LAB NORMALIZATION; k, j= "+k+"  "+j);
            System.out.println("....norm error = "+getNormErrorVx(dRays[k][j])); 
        }
        // System.out.println("vxtolab() being called; surf[OZ] = "+surf[OZ]); 
        
        x  = dRays[k][j][RTXL];
        y  = dRays[k][j][RTYL];
        z  = dRays[k][j][RTZL];    
        u  = dRays[k][j][RTUL];
        v  = dRays[k][j][RTVL];
        w  = dRays[k][j][RTWL];          
        // System.out.printf("vxtolab input  x,y,z,u,v,w = %8.4f %8.4f %8.4f %8.4f %8.4f %8.4f \n", x,y,z,u,v,w);   

        dRays[k][j][RU] = surfs[j][OE11]*u + surfs[j][OE12]*v + surfs[j][OE13]*w;
        dRays[k][j][RV] = surfs[j][OE21]*u + surfs[j][OE22]*v + surfs[j][OE23]*w;
        dRays[k][j][RW] = surfs[j][OE31]*u + surfs[j][OE32]*v + surfs[j][OE33]*w;

        dRays[k][j][RX] = surfs[j][OE11]*x + surfs[j][OE12]*y + surfs[j][OE13]*z;
        dRays[k][j][RY] = surfs[j][OE21]*x + surfs[j][OE22]*y + surfs[j][OE23]*z;
        dRays[k][j][RZ] = surfs[j][OE31]*x + surfs[j][OE32]*y + surfs[j][OE33]*z;
        
        x = dRays[k][j][RX] += surfs[j][OX];
        y = dRays[k][j][RY] += surfs[j][OY];
        z = dRays[k][j][RZ] += surfs[j][OZ];
        u = dRays[k][j][RU];
        v = dRays[k][j][RV]; 
        w = dRays[k][j][RW];
        // System.out.printf("vxtolab output x,y,z,u,v,w = %8.4f %8.4f %8.4f %8.4f %8.4f %8.4f \n", x,y,z,u,v,w);  
        rayok = isNormalizedLab(dRays[k][j]);
        if (!rayok)
        {
            System.out.println("vxtolab() exitting with BAAD LAB NORMALIZATION; k, j = "+k+"  "+j);
            System.out.println("....norm error = "+getNormErrorLab(dRays[k][j]));     
        }    
    }

    
    static private void clobberUVW(int k, int j)
    // used only to zero out failed redirections to blank InOut and graphic data points.
    // Assumes that InOut, Plot2D and Plot3D skip minus zero data!
    {
        dRays[k][j][RTUL] = -0.0; 
        dRays[k][j][RTVL] = -0.0;
        dRays[k][j][RTWL] = +1.0; 
        dRays[k][j][RU]   = -0.0;
        dRays[k][j][RV]   = -0.0;
        dRays[k][j][RW]   = +1.0;
    }

    static private void clobberAll(int k, int j)
    // clears out a skipped ray surface combo.
    {
        dRays[k][j][RTXL] = -0.0; 
        dRays[k][j][RTYL] = -0.0;
        dRays[k][j][RTZL] = -0.0; 
        dRays[k][j][RX]   = -0.0;
        dRays[k][j][RY]   = -0.0;
        dRays[k][j][RZ]   = -0.0;
        dRays[k][j][RTUL] = -0.0; 
        dRays[k][j][RTVL] = -0.0;
        dRays[k][j][RTWL] = -0.0; 
        dRays[k][j][RU]   = -0.0;
        dRays[k][j][RV]   = -0.0;
        dRays[k][j][RW]   = -0.0;
    }
    
    static private void vExtendLabs(int kray)
    // Extends lab coords of a failed ray for layout dotted indicator.
    // Extends from howfarOK[k] to howfarOK[k]+1.
    // Just like vPropagate() but used only for failed rays. 
    // Extension length depends on OEJIF size metric via DMF.getOsize().
    // Does not update ray[RPATH] nor should it. 
    // Apply this only AFTER each ray's loop terminates with bExtend[]=true.
    {
        int j = howfarOK[kray];
        String fracStr = DMF.reg.getuo(UO_LAYOUT, 39); // factory default: B4constants line 870
        double frac = 0.01* Double.parseDouble(fracStr);  
        double size = DMF.getOsize();
        double dist = frac * size;
        if (DEBUG)
        {  
            System.out.println("RT13.vExtendLabs() is extending LAB coords starting at howfarOK = "+j); 
            System.out.printf("RT13.vExtendLabs() has frac, size, dist = %9.3f %9.3f %9.3f \n", frac, size, dist); 
        }
        dRays[kray][j+1][RX] = dRays[kray][j][RX] + dRays[kray][j][RU] * dist; 
        dRays[kray][j+1][RY] = dRays[kray][j][RY] + dRays[kray][j][RV] * dist; 
        dRays[kray][j+1][RZ] = dRays[kray][j][RZ] + dRays[kray][j][RW] * dist; 
    }


    static private void fixupLabUVW(int k)
    {
        int j = 0; 
        double sign = dRays[k][j][RW] < 0 ? -1.0 : +1.0;
        double sos = U.sqr(dRays[k][j][RU]) + U.sqr(dRays[k][j][RV]);
        if (sos > 1.0)
        {
            double r = Math.sqrt(sos);
            dRays[k][j][RU] /= r;
            dRays[k][j][RV] /= r;
            dRays[k][j][RW] = 0.0; 
        }
        else     
            dRays[k][j][RW] = sign*Math.sqrt(1 - sos);
        boolean rayok = isNormalizedLab(dRays[k][j]);
        if (!rayok)
            System.out.println("fixupLabUVW() exitting, failed lab normalization.");            
    } 
        
        

    static private void normalizeLab(double ray[])
    // Normalizes ray components RU RV RW in lab frame
    // Does not repair minus zeros. 
    {
        double r2 = ray[RU]*ray[RU] + ray[RV]*ray[RV] + ray[RW]*ray[RW]; 
        if (r2 > 0)
        {
            double r = Math.sqrt(r2); 
            ray[RU] /= r; 
            ray[RV] /= r; 
            ray[RW] /= r; 
            return; 
        }
        ray[RU] = 0.0; 
        ray[RV] = 0.0; 
        ray[RW] = 1.0; 
    }

    static private void normalizeVx(double ray[])
    // affects all components RTUL RTVL RTWL in vertex frame
    {
        double r2 = ray[RTUL]*ray[RTUL] + ray[RTVL]*ray[RTVL] + ray[RTWL]*ray[RTWL]; 
        if (r2 > 0)
        {
            double r = Math.sqrt(r2); 
            ray[RTUL] /= r; 
            ray[RTVL] /= r; 
            ray[RTWL] /= r; 
            return; 
        }
        ray[RTUL] = 0.0; 
        ray[RTVL] = 0.0; 
        ray[RTWL] = 1.0; 
    }


    static private double getNormErrorVx(double[] ray)
    {
        return ray[RTUL]*ray[RTUL] + ray[RTVL]*ray[RTVL] + ray[RTWL]*ray[RTWL] - 1.0; 
    }
    
    static private boolean isNormalizedVx(double[] ray)
    {
        double err = getNormErrorVx(ray); 
        return Math.abs(err) < TOL;  
    }
    
    static private double getNormErrorLab(double[]  ray)
    {
       return U.sqr(ray[RU]) + U.sqr(ray[RV]) + U.sqr(ray[RW]) - 1.0;
    }

    static private boolean isNormalizedLab(double[] ray)
    {
        double err = getNormErrorLab(ray);
        return Math.abs(err) < TOL;
    }


    static int iGetRoots(double abc[], double xx[])
    // finds all roots including phantom hyperboloid & ellipse farside
    {
        double a = abc[0]; 
        double b = abc[1]; 
        double c = abc[2]; 
        xx[0] = xx[1] = -0.0; 

        if (a == 0.0)
        {
            if (b == 0.0)
              return 0; 
            xx[0] = xx[1] = -c/b; 
            return 1; 
        }
        if (c == 0.0)
        {
            xx[0] = 0.0; 
            xx[1] = -b/a; 
            return 2;
        }
        if (b == 0.0)
        {
            if (c/a > 0.0)
              return 0;
            xx[0]= Math.sqrt(-c/a); 
            xx[1] = -xx[0];  
            return 2;
        }

        //-------abc all nonzero-----

        double discrim = b*b-4.0*a*c; 
        if (discrim < 0.0)
          return 0; 
        if (discrim == 0.0)
        {
            xx[0] = xx[1] = -b/(2*a); 
            return 2; 
        }
        double root = Math.sqrt(discrim); 
        double q = (b>0.0) ? (b+root)/2 : (b-root)/2; 
        xx[0] = -c/q; 
        xx[1] = -q/a; 
        return 2;       
    }


    static int iGetPosRoots(double abc[], double xx[])
    // Returns only positive roots from iGetRoots().
    // Does not prohibit phantom or farside roots.
    // Called by  dQuadSolve(). 
    // REPLACING "TOL" WITH 0.0 as an experiment
    {
        double tol = 0.0; // TOL from B4Constants.java
        int nroots = iGetRoots(abc, xx); 

        int result=0;        
        switch(nroots)
        {
           case 0:  result= -1; break;        // RPMIS 
           case 1:  if (xx[0]>tol) 
                      { result= 1; break;}      // one possible root
                    else
                      {result=0; break; }      // RPBAK 
           case 2:  if (xx[0]>xx[1]) 
                      swap(xx);  
                    if (xx[1]<tol)
                      {result=0; break;}      // RPBAK
                    if (xx[0]>tol)
                      {result= 2; break;}      // two possible roots
                    xx[0] = xx[1];   
                      {result= 1; break;}        // one possible root 
           default: result=0; break;          // SNH
        }

        return result; 
    }


    static void swap(double xx[])
    {
       double t = xx[0]; 
       xx[0] = xx[1]; 
       xx[1] = t; 
    }

} //------------------end of RT13--------------------------------





/** private class MinFit
  * Fits linear function a+bx+cy to collected data xyf[][]
  * @author M.Lampton (c) STELLAR SOFTWARE 2008 all rights reserved.
  */
class MinFit
{
    static double getABC(int n, double data[][], 
    int jx, int jy, int jf, double abc[])
    // Fits {a,b,c} to f(x,y); model = a + b*x + c*y
    // data[][]: first index specifies the data point 0<=i<n; 
    // second index specifies data column: jx or jy or jf.
    // Bias-free even for <data> that is nonzero. 
    // Returns denominator determinant: zero = no fit possible.
    {
        double sums[] = new double[9]; 
        getSums(n, data, jx, jy, jf, sums); 
        
        //----now build the four 3x3 1-D matrices---

        double mat[][] = new double[4][9]; 
        for (int i=0; i<4; i++)
          for (int j=0; j<9; j++)
            mat[i][j] = getElement(i, j, sums); 

        //----finally do the four determinants & ratios----

        for (int i=0; i<3; i++)
          abc[i] = 0.0; 
        double denom = get3x3Det(mat[0]);
        if (denom != 0.0)
          for (int i=0; i<3; i++)
            abc[i] = get3x3Det(mat[i+1])/denom; 
        return denom;
    }

    static void getSums(int n, double xyf[][], 
    int jx, int jy, int jf, double s[])
    {
        for (int j=0; j<9; j++)
          s[j] = 0.0; 
        for (int i=0; i<n; i++)
        {
            s[0] += 1; 
            s[1] += xyf[i][jx]; 
            s[2] += xyf[i][jy]; 
            s[3] += xyf[i][jx]*xyf[i][jx];
            s[4] += xyf[i][jy]*xyf[i][jy]; 
            s[5] += xyf[i][jx]*xyf[i][jy]; 
            s[6] += xyf[i][jf]; 
            s[7] += xyf[i][jx]*xyf[i][jf]; 
            s[8] += xyf[i][jy]*xyf[i][jf]; 
        }
    }

    static double getElement(int m, int i, double sum[])
    // Copy the appropriate sum into one matrix element. 
    // Index m specifies which kind of matrix: 
    // m=0 is denom; m=1 is anum; 2=bnum; 3=cnum.
    // Index i=0...8 is matrix element sought.
    {
        switch (i)
        {
           case 0: return (m==1) ? sum[6] : sum[0];
           case 1: return (m==2) ? sum[6] : sum[1];
           case 2: return (m==3) ? sum[6] : sum[2]; 
           case 3: return (m==1) ? sum[7] : sum[1];
           case 4: return (m==2) ? sum[7] : sum[3];
           case 5: return (m==3) ? sum[7] : sum[5];
           case 6: return (m==1) ? sum[8] : sum[2];
           case 7: return (m==2) ? sum[8] : sum[5]; 
           case 8: return (m==3) ? sum[8] : sum[4];
           default: return 0.0;
        }
    }

    static double get3x3Det(double a[])
    // Determinant of a 3x3 real matrix written as a 9-element vector. 
    {
       return a[0]*(a[4]*a[8] - a[5]*a[7])
             -a[1]*(a[3]*a[8] - a[5]*a[6])
             +a[2]*(a[3]*a[7] - a[4]*a[6]); 
    }
}
